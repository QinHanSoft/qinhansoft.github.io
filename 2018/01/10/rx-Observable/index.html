<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Observable | 长桥の情书</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Observable</h1><a id="logo" href="/.">长桥の情书</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Observable</h1><div class="post-meta">Jan 10, 2018</div><a data-disqus-identifier="2018/01/10/rx-Observable/" href="/2018/01/10/rx-Observable/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>在ReactiveX中，一个观察者（Observer）订阅一个可观察对象（Observable）。观察者对Observable发射的数据或数据序列做出响应。这种模式可以极大地简化并发操作，因为它创建了一个处于待命状态的观察者哨兵，在未来某个时刻响应Observable的通知，不需要阻塞等待Observable发射数据。</p>
<p>这篇文章会解释什么是响应式编程（reactive pattern），以及什么是可观察对象（Observables）和观察者（Observers），其它几篇文章会展示如何用操作符组合和改变Observable的行为。</p>
<h3 id="2-背景知识"><a href="#2-背景知识" class="headerlink" title="2. 背景知识"></a>2. 背景知识</h3><p>在很多软件编程任务中，或多或少你都会希望你写的代码能按照编写的顺序，一次一个的顺序执行和完成。但在ReactiveX中，很多指令可能是并行执行的，之后它们的结果才会被观察者捕获，顺序是不确定的。为达到这个目的，你定义一种获取和变换数据的机制，而不是调用一个方法。在这种机制下，存在一个可观察对象（Observable），观察者（Observer）订阅（Subscribe）它，当数据就绪时，之前定义的机制就会分发数据给一直处于等待状态的观察者哨兵。</p>
<p>这种方法的优点是，如果你有大量的任务要处理，它们互相之间没有依赖关系。你可以同时开始执行它们，不用等待一个完成再开始下一个（用这种方式，你的整个任务队列能耗费的最长时间，不会超过任务里最耗时的那个）。</p>
<p>有很多术语可用于描述这种异步编程和设计模式，在本文里我们使用这些术语：<em>一个观察者订阅一个可观察对象</em>（An observer subscribes to an Observable）。通过调用观察者的方法，Observable发射数据或通知它的观察者。</p>
<p>在其他的文档和场景里，有时我们也将<em>Observer</em>叫做Subscriber、Watcher、Reactor。这个模型通常被称作Reactor模式。</p>
<h3 id="3-创建观察者"><a href="#3-创建观察者" class="headerlink" title="3. 创建观察者"></a>3. 创建观察者</h3><p>本文用类似于Groovy的伪代码举例，但是ReactiveX有多种语言的实现。</p>
<p>普通的方法调用（不是某种异步方法，也不是Rx中的并行调用）。流程通常是这样的：</p>
<ol>
<li>调用某一个方法</li>
<li>用一个变量保存方法返回的结果</li>
<li>使用这个变量和它的新值做些有用的事</li>
</ol>
<p>用代码描述就是：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// make the call, assign its return value to 'returnVal'</span></div><div class="line">returnVal = someMethod(itsParameters);</div><div class="line"><span class="comment">// do something useful with returnVal</span></div></pre></td></tr></table></figure></p>
<p>在异步模型中流程更像是这样的：</p>
<ol>
<li>定义一个方法，它完成某些任务，然后从异步调用中返回一个值，这个方法是观察者的一部分</li>
<li>将这个异步调用本身定义为Observable</li>
<li>观察者通过订阅（Subscribe）操作关联到那个Observable</li>
<li>继续你的业务逻辑，等方法返回时，Observable会发射结果，观察者的方法会开始处理结果或结果集</li>
</ol>
<p>用代码描述就是：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Defines, but does not invoke, the Subscriber's onNext handler</span></div><div class="line"><span class="comment">// (In this example, the observer is very simple and has only an onNext handler)</span></div><div class="line"><span class="keyword">def</span> myOnNext = &#123; it -&gt; do something useful with it &#125;;</div><div class="line"></div><div class="line"><span class="comment">// Defines, but does not invoke, the Observable</span></div><div class="line"><span class="keyword">def</span> myObservable = someObservable(itsParameters);</div><div class="line"></div><div class="line"><span class="comment">// Subscribes the Subscriber to the Observable, and invokes the Observable</span></div><div class="line">myObservable.subscribe(myOnNext);</div><div class="line"></div><div class="line"><span class="comment">// Go on about my business</span></div></pre></td></tr></table></figure></p>
<h3 id="4-回调方法（onNext-onCompleted-onError）"><a href="#4-回调方法（onNext-onCompleted-onError）" class="headerlink" title="4. 回调方法（onNext, onCompleted, onError）"></a>4. 回调方法（onNext, onCompleted, onError）</h3><p>Subscribe方法用于将观察者连接到Observable，你的观察者需要实现以下方法的一个子集：</p>
<ul>
<li><strong>onNext(T item)</strong><br>  Observable调用这个方法发射数据，方法的参数就是Observable发射的数据，这个方法可能被调用多次，取决于你的实现。</li>
<li><strong>onError(Exception ex)</strong><br>  当Observable遇到错误或无法返回期望的数据时会调用这个方法，这个调用会终止Observable，后续不会再调用onNext和onCompleted，onError方法的参数是抛出的异常。</li>
<li><strong>onCompleted()</strong><br>  正常终止，如果没有遇到错误，Observable在最后一次调用onNext之后调用此方法。</li>
</ul>
<p>根据Observable协议的定义，onNext可能会被调用零次或多次，最后会有一次onCompleted或onError调用（不会同时），传递数据给onNext通常会被称作发射，onCompleted和onError被称作通知。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> myOnNext        = &#123; item -&gt; <span class="comment">/* do something useful with item */</span> &#125;;</div><div class="line"><span class="keyword">def</span> myError          = &#123; throwable -&gt; <span class="comment">/* react sensibly to failed call */</span> &#125;;</div><div class="line"><span class="keyword">def</span> myComplete      = &#123; <span class="comment">/* clean up after the final response */</span> &#125;;</div><div class="line"><span class="keyword">def</span> myObservable    = someMethod(itsParameters);</div><div class="line">myObservable.subscribe(myOnNext, myError, myComplete);</div><div class="line"></div><div class="line"><span class="comment">// go on about my business</span></div></pre></td></tr></table></figure>
<h3 id="5-取消订阅（Unsubscribing）"><a href="#5-取消订阅（Unsubscribing）" class="headerlink" title="5. 取消订阅（Unsubscribing）"></a>5. 取消订阅（Unsubscribing）</h3><p>在以下ReactiveX实现中，有一个特殊的观察者接口Subscriber，它有一个unsubscribe方法。调用这个方法表示你不关心当前订阅的Observable了，因此Observable可以选择停止发射新的数据项（如果没有其他观察者订阅）。</p>
<p>取消订阅的结果会传递给这个Observable的操作符链，而且会导致这个链条上的每个环节都停止发射数据项。这些并不保证会立即发生，然而，对一个Observable来说，即使没有观察者了，它也可以在一个while循环中继续生成并尝试发射数据项。</p>
<h3 id="6-关于命名约定"><a href="#6-关于命名约定" class="headerlink" title="6. 关于命名约定"></a>6. 关于命名约定</h3><p>ReactiveX的每种特定语言的实现都有自己的命名偏好，虽然不同的实现之间有很多共同点，但并不存在一个统一的命名标准。</p>
<p>而且，在某些场景中，一些名字有不同的隐含意义，或者在某些语言看起来比较怪异。</p>
<p>例如，有一个onEvent命名模式（onNext，onCompleted，onError），在一些场景中，这些名字可能意味着时间处理器已经注册。然而在ReactiveX里，它们是事件处理器的名字。</p>
<h3 id="7-Observables的“热”和“冷”"><a href="#7-Observables的“热”和“冷”" class="headerlink" title="7. Observables的“热”和“冷”"></a>7. Observables的“热”和“冷”</h3><p>Observable什么时候开始发射数据序列？这取决于Observable的实现，一个“热”的Observable可能一创建完就开始发射数据，因此所有后续订阅它的观察者可能从序列中间的某个位置开始接受数据（有一些数据错过了）。一个“冷”的Observable会一直等待，直到有观察者订阅它才开始发射数据，因此这个观察者可以确保会收到整个数据序列。</p>
<p>在一些ReactiveX实现里，还存在一种被称作Connectable的Observable，不管有没有观察者订阅它，这种Observable都不会开始发射数据，除非connect方法被调用。</p>
<h3 id="8-用操作符组合Observable"><a href="#8-用操作符组合Observable" class="headerlink" title="8. 用操作符组合Observable"></a>8. 用操作符组合Observable</h3><p>对于ReactiveX来说，Observable和Observer仅仅是个开始，它们本身不过是标准观察者模式的一些轻量级扩展，目的是为了更好的处理事件序列。</p>
<p>ReactiveX真正强大的地方在于它的操作符，操作符让你可以变换、组合、操纵和处理Observable发射的数据。</p>
<p>Rx的操作符让你可以用声明式的风格异步操纵序列，它拥有回调的所有效率优势，同时又避免了典型的异步系统中嵌套回调的缺点。</p>
<p>下面是常用的操作符列表：</p>
<ol>
<li>创建操作：Create、Defer、Empty/Never/Throw、From、Interval、Just、Range、Repeat、Start、Timer</li>
<li>变换操作：Buffer、FlatMap、GroupBy、Map、Scan和Window</li>
<li>过滤操作：Debounce、Distinct、ElementAt、Filter、First、IgnoreElements、Last、Sample、Skip、SkipLast、Take、TakeLast</li>
<li>组合操作：And/Then/When、CombineLatest、Join、Merge、StartWith、Switch、Zip</li>
<li>错误处理：Catch和Retry</li>
<li>辅助操作：Delay、Do、Materialize/Dematerialize、ObserveOn、Serialize、Subscribe、SubscribeOn、TimeInterval、Timeout、Timestamp、Using</li>
<li>条件和布尔操作：All、Amb、Contains、DefaultIfEmpty、SequenceEqual、SkipUntil、SkipWhile、TakeUntil、TakeWhile</li>
<li>算术和集合操作：Average、Concat、Count、Max、Min、Reduce、Sum</li>
<li>转换操作：To</li>
<li>连接操作：Connect、Publish、RefCount、Replay</li>
<li>反压操作：用于增加特殊的流程控策略的操作符</li>
</ol>
<p>这些操作符并不全都是ReactiveX的核心组成部分，有一些是语言特定的实现或可选的模块。</p>
<h3 id="9-RxJava"><a href="#9-RxJava" class="headerlink" title="9. RxJava"></a>9. RxJava</h3><p>在RxJava中，一个实现了<em>Observer</em>接口的对象可以订阅（subscribe）一个Observable的实例。订阅者（subscriber）对Observable发送（emit）的任何数据或数据序列做出响应。这种模式简化了并发操作，因为它不需要阻塞等待Observable发射数据，而是创建了一个处于待命状态的观察者哨兵，哨兵在未来某个时刻响应Observable的通知。</p>
<style type="text/css">
    p {
        text-indent: 2em; /*首行缩进*/
    }
</style>
</div><div class="tags"></div><div class="post-nav"><a href="/2018/01/11/rx-Single/" class="pre">Single</a><a href="/2018/01/10/rx-ReactiveX/" class="next">ReactiveX</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = '长桥の情书';
var disqus_identifier = '2018/01/10/rx-Observable/';
var disqus_title = 'Observable';
var disqus_url = 'http://yoursite.com/2018/01/10/rx-Observable/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//长桥の情书.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/25/Day05-breaking/">第五天</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/24/Day04-breaking/">第四天</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/23/Day03-breaking/">第三天</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/22/Day02-breaking/">第二天</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/Day01-breaking/">第一天</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/14/Android-intent-bug/">Android 使用Intent传递参数时的一个bug</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/26/rx-Operate-Create-Start/">Start</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/Build-a-Responseive-UI-with-ConstraintLayout/">Build a Responseive UI with ConstraintLayout</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/17/html5-fkjava-char2/">疯狂HTML 5+CSS 3+JavaScript讲义笔记——2.HTML 5的常用元素与属性</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Error/">Error</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//长桥の情书.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">长桥の情书.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>