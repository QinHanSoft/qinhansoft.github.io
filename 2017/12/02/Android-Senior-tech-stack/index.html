<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android高级进阶笔记-基于开源项目搭建属于自己的技术堆栈 | 长桥の情书</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android高级进阶笔记-基于开源项目搭建属于自己的技术堆栈</h1><a id="logo" href="/.">长桥の情书</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android高级进阶笔记-基于开源项目搭建属于自己的技术堆栈</h1><div class="post-meta">Dec 2, 2017</div><a data-disqus-identifier="2017/12/02/Android-Senior-tech-stack/" href="/2017/12/02/Android-Senior-tech-stack/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>在Android应用开发过程中，几乎每个App都具有的与业务无关的底层基础能力。Android发展到现在，已经处于成熟稳定期，相信每个靠谱的移动互联网公司都已经搭建起自己的一套通用的基础开发框架，服务于公司内部各大产品线的移动端产品。有一定经验的Android开发者，也都或多或少在心中或者实践中有自己的一套基础开发工具集。无论是公司还是个人，这套基础开发框架中肯定都包含开源的数据库或者第三方的SDK以及自己研发或者总结的函数库，比不过比例不同而已。为了从整体架构上进行把握，我们先来看看一个完整的App整体架构。</p>
<h3 id="1-App的整体架构"><a href="#1-App的整体架构" class="headerlink" title="1. App的整体架构"></a>1. App的整体架构</h3><p>从较高的层次讲，一个App的整体架构可以分成两层，即应用层和基础框架层。</p>
<ul>
<li>应用层专注于行业领域的实现，例如金融、支付、地图导航、社交等，它直接面向用户，是用户对产品的第一感知；</li>
<li>基础框架层专注于技术领域的实现，提供App公有的特性，避免重复造轮子，它是用户对产品的第二层感知，例如性能、稳定性等。</li>
</ul>
<p>一个理想的App架构，首先应该是支持跨平台开发的；其次应该具有清晰的层次划分，同一层模块间充分解耦，模块内部符合面向对象设计六大原则；最后应该在功能、性能、稳定性等方面达到综合最优。基于以上设计原则，我们可以得到如下图所示的App架构图，最上层是应用层，应用层以下都属于基础框架层，可以看到基础框架层包括：组件层、基础层和跨平台层。<img src="https://github.com/QinHanSoft/BlogImages/blob/master/Android-App-frame-level.png?raw=true" alt=""></p>
<p>下面就开始一步一步地阐述如何基于开源函数库搭建属于自己的一个基础技术堆栈。</p>
<h3 id="2-技术选型的考量点"><a href="#2-技术选型的考量点" class="headerlink" title="2. 技术选型的考量点"></a>2. 技术选型的考量点</h3><p>首先要明确的是，我们选择开元函数库或者第三方SDK，一般需要综合考虑以下几个方面：</p>
<ul>
<li>特性：提供的特性是否满足项目的需求；</li>
<li>可用性：是否提供了简单便利的API，方便开发者集成使用；</li>
<li>性能：性能不能太差，否则项目后面性能优化会过不去，可能会出现需要替换函数库的情况；</li>
<li>文档：文档应该比较齐全，且可读性强；</li>
<li>技术支持：遇到问题或者发现bug，是否能够及时得到官方的技术支持是很重要的；</li>
<li>大小：引入函数库会增加APK的大小，需要慎重抉择；</li>
<li>方法数：如果函数库方法数太多，积累起来会导致App遇到64K问题，应该尽量避免。</li>
</ul>
<h3 id="3-日志记录能力"><a href="#3-日志记录能力" class="headerlink" title="3. 日志记录能力"></a>3. 日志记录能力</h3><p>日志记录无论在服务端开发还是移动端开发，都是一个基础且重要的能力。开发人员在代码调试以及错误定位过程中，大多时候都要依赖日志信息，一个简洁灵活的日志记录模块是相当重要的。Android系统提供了Log类来记录日志，在Android开发最初的几年，我们几乎都是对这个Log类进行简单的封装，例如增加全局控制是否打印日志的开关、增加打印到文件的能力等。知道我们遇到了<a href="https://github.com/orhanobut/logger" target="_blank" rel="external">Logger</a>这个开源日志记录库，才认识到日志记录还可以这么玩。Logger同样是基于系统Log类基础上进行的封装，但新增了如下超赞的特性：</p>
<ul>
<li>在Logcat中完美的格式化输出，再也不用担心和手机其他App或者系统的日志信息相混淆了；</li>
<li>包含线程、类、方法信息，可以清楚地看到日志记录的调用堆栈；</li>
<li>支持跳转到源码处；</li>
<li>支持格式化输出JSON、XML格式信息。</li>
</ul>
<p>当然Logger也不是完备的，它虽然支持JSON、XML的格式化输出，但并不支持诸如List、Set、Map和数组等常见Java集合类的格式化输出。那么如何解决呢？如果不想自己添加，可以参考<a href="https://github.com/pengwei1024/LogUtils" target="_blank" rel="external">LogUtils</a>工具库，它实现了Logger缺失的上述特性。</p>
<p>再者，Logger只支持输出日志到Logcat，但项目开发中往往还存在将日志保存到磁盘上的需求，如何将两者结合起来呢？这时我们遇到了<a href="https://github.com/JakeWharton/timber" target="_blank" rel="external">timber</a>。</p>
<p>timber是JakeWharton开源的一个日志记录库，它的特点是可扩展框架，开发者开源方便快捷地集成不同类型的日志记录方式，例如打印到Logcat、打印日志到文件、打印日志到网络等，timer通过一行代码就可以同时调用多种方式。</p>
<p>timber的思想很简单，就是维护一个森林对象，它由不同类型的日志树组合而成，例如Logcat记录树、文件记录树、网络记录树等，森林对象提供对外的接口进行日志打印。每种类型的树都可以通过种植操作来把自己添加到森林对象中，或者通过移除操作从森林对象中删除，从而实现该类型日志记录的开启和关闭。</p>
<p>因此，最终我们的日志记录模块将由timber+Logger+LogUtils组成，当然轮子找到了，轮子的兼容合并就要靠我们自己去实现了，同时我们还得增加打印到文件的日志树和打印到网络的日志树实现。</p>
<h3 id="4-JSON解析能力"><a href="#4-JSON解析能力" class="headerlink" title="4. JSON解析能力"></a>4. JSON解析能力</h3><p>移动互联网产品与服务器端通信的数据格式，如果没有特殊需求的话，一般都使用JSON格式。Android系统也原生地提供了JSON解析的API，但是它的速度非常慢，而且没有提供简洁方便的接口来提高开发者的效率和降低出错的可能。因此，通常情况下，我们都会重新选择其他优秀的JSON解析实现，用以替代系统的API。经过多年的发展，目前JSON解析的开源实现主要包括如下几种。</p>
<h4 id="4-1-gson"><a href="#4-1-gson" class="headerlink" title="4.1 gson"></a>4.1 <a href="https://github.com/google/gson" target="_blank" rel="external">gson</a></h4><p>gson是Google出品的JSON解析函数库，可以将JSON字符串发序列化为对应的Java对象，或者反过来将Java对象序列化为对应的JSON字符串，免去了开发者手动通过JSONObject和JSONArray将JSON字段逐个进行解析的烦恼，也减少了出错的可能性，增强了代码的质量。使用gson解析时，对应的Java实体类无需使用注解进行标记，支持任意复杂Java对象包括没有源代码的对象。</p>
<h4 id="4-2-jackson"><a href="#4-2-jackson" class="headerlink" title="4.2 jackson"></a>4.2 <a href="https://github.com/FasterXML/jackson" target="_blank" rel="external">jackson</a></h4><p>jackson是Java语言的一个流行的JSON函数库，在Android开发中使用时，主要包含三部分。</p>
<ul>
<li><a href="https://github.com/FasterXML/jackson-core" target="_blank" rel="external">jackson-core</a>：JSON流处理核心库；</li>
<li><a href="https://github.com/FasterXML/jackson-databind" target="_blank" rel="external">jackson-databind</a>：数据绑定函数库，实现Java对象和JSON字符串流的相互转换；</li>
<li><a href="https://github.com/FasterXML/jackson-annotations" target="_blank" rel="external">jackson-annotations</a>：databind使用的注解函数库。</li>
</ul>
<p>由于jackson是针对Java语言通用的JSON函数库，并没有为Android优化定制过，因此数据包中包含很多非必须的API，相比其他JSON函数库，用于Android平台会更显著的增大最终生成的APK的体积。</p>
<h4 id="4-3-Fastjson"><a href="#4-3-Fastjson" class="headerlink" title="4.3 Fastjson"></a>4.3 <a href="https://github.com/alibaba/fastjson" target="_blank" rel="external">Fastjson</a></h4><p>Fastjson是阿里巴巴出品的一个Java语言编写的高性能且功能完善的JSON函数库。它采用一种“假定有序快速匹配”的算法，吧JSON Parse的性能提升到了极致，号称是目前Java语言中最快的JSON库。Fastjson接口简单易用，已经被广泛使用在缓存序列化、协议交互、Web输出、Android客户端等多种使用场景。</p>
<p>由于是Java语言通用的，因此，以前在Android上使用时，Fastjson不可避免的引入了很多对于Android而言冗余的功能，从而增加了包大小，很多人使用的就是标准版的fastjson，但事实上，fastjson还存在一个专门为Android定制的版本——<a href="https://github.com/ablibaba/fastjson/wiki/Android%E7%89%88%E6%9C%AC" target="_blank" rel="external">fastjson.android</a>。和标准版相比，Android版去掉了一些Android虚拟机dalvik不支持的功能，是的jar更小。</p>
<h4 id="4-4-LoganSquare"><a href="#4-4-LoganSquare" class="headerlink" title="4.4 LoganSquare"></a>4.4 <a href="https://github.com/bluelinelabs/LoganSquare" target="_blank" rel="external">LoganSquare</a></h4><p>LoganSquare是近两年崛起的快速解析和序列化JSON的Android函数库，其底层基于jackson的streaming API，使用APT（Android Annotation Tool）实现编译时注解，从而提高JSON解析和序列化的性能。单从性能方面看，LoganSquare应该是完胜gson和jackson的，如果和fastjson相比较，两者应该是不分伯仲的。</p>
<p>总结起来，四个函数库的包大小分别如下：</p>
<ul>
<li>gson：232K</li>
<li>jackson：259+47+1229 = 1.5M</li>
<li>Fastjson：417K</li>
<li>Fastjson.android：256K</li>
<li>LoganSquare：48+259 = 307K</li>
</ul>
<p>从性能和包大小综合考虑，最终我们会选择fastjson.android作为基础技术堆栈中的JSON解析和序列化库。</p>
<h3 id="5-数据库操作能力"><a href="#5-数据库操作能力" class="headerlink" title="5. 数据库操作能力"></a>5. 数据库操作能力</h3><p>无论是iOS还是Android平台，底层数据库都是基于开源的SQLite实现，然后在系统层封装成用于应用层的API。虽然直接使用系统的数据库API性能很高，但是这些API接口并不是很方便开发者使用，一不小心就会引入bug，而且代码的视觉效果也不佳。为了解决这个问题，一系列的UI小关系映射（ORM）框架涌现了出来，这其中比较知名且广泛使用的有：<a href="https://github.com/pardom/ActiveAndroid" target="_blank" rel="external">ActiveAndroid</a>、<a href="https://github.com/j256" target="_blank" rel="external">ormlite</a>和<a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="external">GreenDao</a>。</p>
<p>2014年7月，一个跨平台的移动数据库引擎<a href="https://realm.io" target="_blank" rel="external">Realm</a>悄然发布，它是专门为移动应用所设计的数据持久化解决方案，支持Android和iOS两大平台，并提供了Objective-C、Swift、Android（Java）三大语言的API。到今天，它的用户已经涵盖很多主流公司。</p>
<h4 id="5-1-ActiveAndroid"><a href="#5-1-ActiveAndroid" class="headerlink" title="5.1 ActiveAndroid"></a>5.1 ActiveAndroid</h4><p>ActiveAndroid是一种Active Record风格的ORM框架，Active Record（活动目录）是Yii、Rails等框架中对ORM实现的典型命名方式。它可以极大的简化数据库的使用，使用面向对象的方式管理数据库，告别手写SQL的历史。每一个数据库表都可以被映射为一个类，开发者只需要使用类似save()或者delete()这样的函数即可。</p>
<p>不过ActiveAndroid已经基本上处于维护阶段了，最新一个Release版本是在2012年发布的。</p>
<h4 id="5-2-ormlite"><a href="#5-2-ormlite" class="headerlink" title="5.2 ormlite"></a>5.2 ormlite</h4><p>ormlite是Java平台的一个ORM框架，支持JDBC连接、Spring和Android平台。在Android中使用时，它包含两个部分。</p>
<ul>
<li><a href="https://github.com/j256/ormlite-core" target="_blank" rel="external">ormlite-core</a>：核心模块，无论在哪个平台使用，都必须基于这个核心库，是实现ORM映射的关键模块；</li>
<li><a href="https://github.com/j256/ormlite-android" target="_blank" rel="external">ormlite-android</a>：基于ormlite-core封装的针对Android平台的适配模块，Android开发中主要跟这个模块打交道。</li>
</ul>
<p>与ActiveAndroid类似，ormlite也已经不是一个活跃的开源库，最近一次Release版本是在2013年发布的。</p>
<h4 id="5-3-greenDAO"><a href="#5-3-greenDAO" class="headerlink" title="5.3 greenDAO"></a>5.3 greenDAO</h4><p>greenDAO是一个轻量级且快速的ORM框架，专门为Android高度优化和定制，它能够支持每秒数千条记录的CRUD操作。我们从<a href="http://greendao-orm.com/2015/09/09/android-orm-performance-in-2015/" target="_blank" rel="external">官网博客</a>上面一张Benchmark图可以看出来它与ormlite和ActiveAndroid的性能对比，如下图所示：<img src="http://greenrobot.org/wordpress/wp-content/uploads/greenDAO-vs-OrmLite-vs-ActiveAndroid.png" alt="">。</p>
<p>纵轴表示每秒执行的操作数。greenDAO依然处于高度活跃中，2017.4.5刚发布了3.2.2版本。</p>
<h4 id="5-4-Realm"><a href="#5-4-Realm" class="headerlink" title="5.4 Realm"></a>5.4 Realm</h4><p>如前面所说，Realm是一个全新的移动数据库引擎，它既不是基于iOS平台的Core Data，也不是基于SQLite，它拥有自己的数据库存储引擎，并实现了高效快速的数据库构建操作。相比Core Data和SQLite，Realm操作要快很多，跟ORM框架相比就更不用说了。</p>
<p>开发者应该尝试使用Realm的理由如下：</p>
<ul>
<li>跨平台：Android和iOS已经是事实上的两大移动互联网操作系统，绝大多数应用都会支持这两个平台。使用Realm，Android和iOS开发者无需考虑内部数据的架构，调用Realm提供的API即可轻松完成数据的交换，实现“一个数据库，两个平台之间无缝衔接”。</li>
<li>用法简单：相比Core Data和SQLite所需的入门知识，Realm可以极大降低开发者的学习成本，快速实现数据存储功能。</li>
<li>可视化操作：Realm为开发者提供了一个轻量级的数据库可视化操作工具，开发者可以轻松查看数据库中的内容，并实现简单地插入和删除等操作。</li>
</ul>
<p>最后，我们来看一下如果引入上述四个函数库的话，分别会给我们的App增加多大的空间：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小 </th>
</tr>
</thead>
<tbody>
<tr>
<td>activeandroid-3.0.jar</td>
<td>40Kb</td>
</tr>
<tr>
<td>greendao-2.1.0.jar</td>
<td>100Kb</td>
</tr>
<tr>
<td>ormlite-android-4.48</td>
<td>57Kb</td>
</tr>
<tr>
<td>realm-android-0.87.1.jar</td>
<td>4.2Mb</td>
</tr>
</tbody>
</table>
<p>前三个ORM框架的大小是在正常范围内的，但Realm的大小一般项目可能无法接受，我们将这个Jar包解压，可以看到里面的内容包含了不同CPU架构平台的.so文件，这增加了整个包的大小，由于arm平台的so在其他平台上面是能够以兼容模式运行的，虽然会损失性能，但这样可以极大地减少函数库占用的空间。因此，可以选择只保留armeabi-v7a和x86这两个平台的.so文件，直接删除无用的.so文件，或者通过在工程的build.gradle文件中增加ndk abi过滤，语句如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    ...</div><div class="line">    defaultConfig &#123;</div><div class="line">        ...</div><div class="line">        ndk &#123;</div><div class="line">            abiFilters <span class="string">"armeabi-v7a"</span>, <span class="string">"x86"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，综合考虑性能，包大小以及开源库的可持续发展等因素，我们最终选择greenDAO。</p>
<h3 id="6-网络通信能力"><a href="#6-网络通信能力" class="headerlink" title="6. 网络通信能力"></a>6. 网络通信能力</h3><p>现在的App几乎都需要从服务器获取数据，不可避免的需要具备网络通信能力，否则会成为一个信息孤岛。</p>
<h4 id="6-1-android-async-http"><a href="#6-1-android-async-http" class="headerlink" title="6.1 android-async-http"></a>6.1 <a href="https://github.com/android-async-http" target="_blank" rel="external">android-async-http</a></h4><p>Android最经典的网络异步通信函数库，做过一段时间Android开发的读者对这个库应该不陌生，它对Apache的<a href="https://hc.apache.org/httpcomponents-client-ga/" target="_blank" rel="external">HttpClient</a> API的封装使得开发者可以简洁优雅地实现网络请求和响应，并且支持同步和异步请求。android-async-http的特性主要如下：</p>
<ul>
<li>支持异步HTTP请求，并在匿名回调函数中处理响应；</li>
<li>在子线程中发起HTTP请求；</li>
<li>内部采用线程池来处理并发请求；</li>
<li>通过RequestParams类实现GET/POST参数构造；</li>
<li>无需第三方库支持即可实现Multipart文件上传；</li>
<li>库的大小只有60KB；</li>
<li>支持多种移动网络环境下自动智能的请求重试机制；</li>
<li>HTTP响应中实现自动的gzip解码，实现快速请求响应；</li>
<li>内置多种形式的响应解析，有原生的字节流、String、JSON对象，甚至可以将response写到文件中；</li>
<li>可选的永久cookie保存，内部实现使用的是Android的SharedPreferences。</li>
</ul>
<p>官方在Android 2.3 开始就推荐开发者使用HttpURLConnection代替Apache的HttpClient。但从Android 6.0开始，由于系统对开发者隐藏了HttpClient的API，这迫使开发者如果要继续使用android-async-http的话，就需要引入额外的HttpClient函数库，这显然增大了使用android-async-http的代价，上面提到的“库的大小只有60KB”依然称为历史。</p>
<p>至于为何Android要移除HttpClient，可以参见<a href="https://developer.android.com/about/versions/marshmallow/android-6.0-changes.html" target="_blank" rel="external">Android 6.0 Changes</a>，如图<img src="https://github.com/QinHanSoft/BlogImages/blob/ebd9e60af432cf313cac52b83dffae46568227da/Android%20marshmallow%20Apache-http-client%20removal.png?raw=true" alt=""></p>
<p>可以看到，如果想继续使用HttpClient，官方推荐的做法是在编译期引入org.apache.http.legacy这个库，这个库可以在Android SDK目录下的platforms/android-23/optional中找到，它的作用是确保在编译时不会出现找不到HttpClient相关API的错误，在应用运行时可以不依赖这个库，因为6.0以上的Android系统还没有真正移除HttpClient的代码，只不过API设置为对开发者不可见。不过通过查看android-async-http的源码发现，它并没有使用官网推荐的这个库，而是使用下面这个函数库来代替一切的Apache的HttpClient，因此我们不能保证在Android的下个版本会不会吧Apache HttpClient真正的从系统源码中彻底移除掉。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">dependencies</span> &#123;</div><div class="line">    <span class="keyword">compile</span> <span class="string">'cz.msebera.android:httpclient:4.3.6'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样显著增加了App的包大小，从Android 6.0开始，如果想继续使用android-async-http，那么你的App需要额外增加1.1MB左右的大小。</p>
<h4 id="6-2-OkHttp"><a href="#6-2-OkHttp" class="headerlink" title="6.2 OkHttp"></a>6.2 <a href="https://github.com/square/okhttp" target="_blank" rel="external">OkHttp</a></h4><p>OkHttp是一个搞笑的HTTP客户端，具有如下特性：</p>
<ul>
<li>支持Http/2和SPDY，对同一台主机的所有请求共享同一个Socket；</li>
<li>当SPDY不可用时，使用连接池减少请求的延迟；</li>
<li>透明的GZIP压缩减少下载数据大小；</li>
<li>缓存响应避免重复的网络请求。</li>
</ul>
<p>OkHttp在网络性能很差的情况下能够很好地工作，它能够避免常见的网络连接问题。如果你的HTTP服务有多个IP地址，OkHttp在第一次连接失败时，会尝试其他可选的地址。这对于IPv4+IPv6已经托管在冗余数据中心的服务来说是必要的。OkHttp使用现代的TLS特性（SNI，ALPN）初始化HTTP连接，当握手失败时，会降级使用TSL1.0尝试初始化连接。</p>
<p>OkHttp依赖与okio，okio作为java.io和java.nio的补偿，是Square公司开发是一个函数库。okio使得开发者可以更方便地访问、存储和处理数据。一开始是作为OkHttp的一个组件存在的，当然我们也可以单独使用它。</p>
<p>使用OkHttp需要引入的jar包如下所示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>okhttp-3.0.1.jar</td>
<td>326KB</td>
</tr>
<tr>
<td>okio-1.6.0.jar</td>
<td>66KB</td>
</tr>
</tbody>
</table>
<h4 id="6-3-Volley"><a href="#6-3-Volley" class="headerlink" title="6.3 Volley"></a>6.3 <a href="https://android.googlesource.com/platform/frameworks/volley" target="_blank" rel="external">Volley</a></h4><p>Volley是Google在Google I/O 2013上面发布的用于Android平台的网络通信库，能使网络通信更快、更简单、更健壮。在Google I/O演讲PPT上，配了一张弓箭发射图来说明Volley特别适用于数据量小等通信频繁的场景。</p>
<p>具体的讲，Volley是为了简化网络任务而设计的，用于帮助开发者处理请求、加载、缓存、多线程、同步等任务。Volley设计了一个灵活的网络栈适配器，在Android 2.2及之前的版本中，Volley底层使用Apache HttpClient，在Android 2.3及以上版本中，它使用HttpURLConnection来发起网络请求，而且开发者也很容易将网络栈切换成使用OkHttp。</p>
<p>Volley官方源码托管在Google Source上面，使用是只能直接以jar包形式引入，如果想在Gradle中使用compile在线引入，可以考虑使用mcxiaoke在Github上的<a href="https://github.com/mcxiaoke/android-volley" target="_blank" rel="external">Volley Mirror</a>，然后在build.gradle中使用如下语句即可。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">compile</span> <span class="string">'com.mcxiaoke.volley:library:1.0.19'</span></div></pre></td></tr></table></figure>
<h4 id="6-4-Retrofit"><a href="#6-4-Retrofit" class="headerlink" title="6.4 Retrofit"></a>6.4 <a href="https://github.com/square/retrofit" target="_blank" rel="external">Retrofit</a></h4><p>确切的说，Retrofit并不是一个完整的网络请求函数库，而是将REST API转换成Java接口的一个开源函数库，它要求服务器API接口遵循REST规范。基于注解是的代码变得很简洁，Retrofit默认情况下使用GSON作为JSON解析器，使用OkHttp实现网络请求，三种通常配合使用，当然我们也可以将这两者替换成其他的函数库。</p>
<p>通过上面的分析可以发现，HttpURLConnection、Apache HttpClient和OKHttp封装了底层的网络请求，而android-async-http、Volley和Retrofit是基于前面三者的基础上二次开发而成。</p>
<p>最后我们来看一下这些函数库的大小，如下表所示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>android-async-http-1.4.9.jar</td>
<td>106KB</td>
</tr>
<tr>
<td>gson-2.3.1.jar</td>
<td>211KB</td>
</tr>
<tr>
<td>httpclient-4.3.6.jar</td>
<td>1.1MB</td>
</tr>
<tr>
<td>okhttp-3.0.1.jar</td>
<td>326KB</td>
</tr>
<tr>
<td>okio-1.6.0.jar</td>
<td>66KB</td>
</tr>
<tr>
<td>org.apache.http.legacy.jar</td>
<td>303KB</td>
</tr>
<tr>
<td>retrofit-1.9.0.jar</td>
<td>122KB</td>
</tr>
<tr>
<td>volley-1.0.19.jar</td>
<td>94KB</td>
</tr>
</tbody>
</table>
<ul>
<li>android-async-http：106KB+1.1MB = 1.2MB</li>
<li>OkHttp：326KB+66KB = 392KB</li>
<li>Volley：94KB</li>
<li>Retrofit：122KB+211KB = 333KB</li>
</ul>
<h3 id="7-图片缓存和显示能力"><a href="#7-图片缓存和显示能力" class="headerlink" title="7. 图片缓存和显示能力"></a>7. 图片缓存和显示能力</h3><p>Android发展到今天，已经出现很多优秀的图片缓存函数库，开发人员可以根据项目实际需求进行选择。传统的图片缓存方案中设置有两级缓存，分别是内存缓存和磁盘缓存。在Facebook推出的Fresco中，它增加了一级缓存，也就是native缓存，这极大地降低了使用Fresco的App出现OOM的概率。</p>
<h4 id="7-1-BitmapFun"><a href="#7-1-BitmapFun" class="headerlink" title="7.1 BitmapFun"></a>7.1 <a href="http://developer.android.com/training/displaying-bitmaps/index.html" target="_blank" rel="external">BitmapFun</a></h4><p>BitmapFun函数库是Android官方教程中的一个图片加载和缓存示例，对于简单的图片加载需求来说，使用BitmapFun就够了，在早期的Android App开发中使用较多，后来随着越来越多成熟强大的函数库的出现，BitmapFun也渐渐退出实际项目开发的舞台。但作为一个入门图片缓存的教程，它依然起着不可忽视的作用，毕竟万变不离其宗。</p>
<h4 id="7-2-Picasso"><a href="#7-2-Picasso" class="headerlink" title="7.2 Picasso"></a>7.2 <a href="https://github.com/square/picasso" target="_blank" rel="external">Picasso</a></h4><p>Picasso是著名的Square公司众多开源项目中的一个，以著名画家毕加索命名。除了实现图片的下载和二级缓存功能，还解决了常见的一些问题：</p>
<ul>
<li>在adatper中正常的处理ImageView回收和下载的取消；</li>
<li>使用尽量小的内存实现复杂的图片变换。</li>
</ul>
<p>在Picasso中，我们使用一行代码就可以实现图片下载并渲染到ImageView中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Picasso.with(context).load(<span class="string">"https://github.com/sample/imageurl"</span>).into(imageView);</div></pre></td></tr></table></figure>
<h4 id="7-3-Glide"><a href="#7-3-Glide" class="headerlink" title="7.3 Glide"></a>7.3 <a href="https://github.com/bumptech/glide" target="_blank" rel="external">Glide</a></h4><p>Glide是Google推荐的用于Android平台上的图片加载和缓存函数库。这个库被广泛应用在Google的开源项目中，Glide和Picasso有90%的相似度，可以说就是Picasso的克隆版本，只是在细节上还是存在不少区别。Glide为包含图片的滚动列表做了尽可能流畅的优化。除了静态图片，Glide也支持GIF格式图片的显示。Glide提供了灵活的API可以让开发者方便地替换下载图片所用的网络函数库，在默认情况下，它使用HttpUrlConnection作为网络请求模块，开发者也可以根据自己项目的实际需求灵活使用Google的Volley或者Square的OkHttp等函数库进行替换。</p>
<p>Glide的使用也可以使用一行代码来完成，语句如下，跟Picasso确实非常相似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Glide.with(context).load(<span class="string">"http://goo.gl/gEgYUd"</span>).into(imageView);</div></pre></td></tr></table></figure>
<h4 id="7-4-Fresco"><a href="#7-4-Fresco" class="headerlink" title="7.4 Fresco"></a>7.4 <a href="https://github.com/facebook/fresco" target="_blank" rel="external">Fresco</a></h4><p>Fresco是Facebook开源的功能强大的图片加载和缓存函数库，相比其他图片缓存库，Fresco最显著的特点是具有三级缓存：两级内存缓存和一级磁盘缓存。它的主要特性如下：</p>
<ul>
<li>渐进式地加载JPEG图片；</li>
<li>显示GIF和WebP动画；</li>
<li>可扩展，可自定义的图片加载和显示；</li>
<li>在Android 4.x和以下的系统上，将图片放在Android内存一个特殊的区域，从而使得应用运行更流畅，同时极大减低出现OutOfMemoryError的错误。</li>
</ul>
<h4 id="7-5-Android-Universal-Image-Loader"><a href="#7-5-Android-Universal-Image-Loader" class="headerlink" title="7.5 Android-Universal-Image-Loader"></a>7.5 <a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="external">Android-Universal-Image-Loader</a></h4><p>Android-Universal-Image-Loader简称UIL，是Android平台老牌的图片下载和缓存函数库，功能强大灵活且高度可自定义，它提供一系列配置选项，并能很好地控制图片加载和缓存的过程。使用者甚多，早期的Android开发者应该都接触过，现在仍然在很多项目中使用。UIL也支持二级缓存，它的主要特性如下：</p>
<ul>
<li>同步或异步的多线程图片加载；</li>
<li>高度可自定义：线程池、下载器、解码器、内存和磁盘缓存、图片显示选项等；</li>
<li>每张图片的显示支持多种自定义选项：默认存根图片、缓存切换、解码选项、Bitmap处理和显示等；</li>
<li>图片可缓存在内存或者磁盘（设备的文件系统或SD卡）上；</li>
<li>可实时监听图片加载流程，包括下载进度。</li>
</ul>
<p>最后来看一下如果引入这些函数库，会给App增加多大的空间，如下表所示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>BitmapFun.jar</td>
<td>71KB</td>
</tr>
<tr>
<td>bolts-android-1.1.4.jar</td>
<td>47KB</td>
</tr>
<tr>
<td>drawee-0.9.0.aar</td>
<td>93KB</td>
</tr>
<tr>
<td>fbcore-0.9.0</td>
<td>93KB</td>
</tr>
<tr>
<td>fresco-0.9.0</td>
<td>10KB</td>
</tr>
<tr>
<td>glide-3.7.0.jar</td>
<td>475KB</td>
</tr>
<tr>
<td>imagepipeline-0.9.0.aar</td>
<td>3MB</td>
</tr>
<tr>
<td>imagepipeline-base-0.9.0.aar</td>
<td>62KB</td>
</tr>
<tr>
<td>imagepipeline-okhttp-0.8.1.aar</td>
<td>8KB</td>
</tr>
<tr>
<td>nineoldandroid-2.4.0.jar</td>
<td>111KB</td>
</tr>
<tr>
<td>picasso-2.5.2.jar</td>
<td>120KB</td>
</tr>
<tr>
<td>universal-image-loader-1.9.5.jar</td>
<td>162KB</td>
</tr>
</tbody>
</table>
<p>可以看到，Fresco函数库的依赖库有很多，除其它几个函数库的Jar包外，其它的都是使用Fresco所需要的依赖。总结起来，四个函数库的包大小分别如下：</p>
<ul>
<li>BitmapFun：71KB</li>
<li>Picasso：120KB</li>
<li>Glide：475KB</li>
<li>Fresco：47KB+93KB+93KB+10KB+3MB+62KB+8KB+111KB=3.4MB</li>
<li>Android-Universal-Image-Loader：162KB</li>
</ul>
<p>图片函数库的选择需要根据App的具体情况而定，对于严重依赖图片缓存的App，例如壁纸类，图片社交类App来说，可以选择最专业的Fresco。对于一般的App，选择Fresco会显得比较重，毕竟Fresco 3.4MB的体量摆在这。根据App对图片显示和缓存的需求从低到高文明可以对以上函数库做义工排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BitmapFun &lt; Picasso &lt; Android-Universal-Image-Loader &lt; Glide &lt; Fresco</div></pre></td></tr></table></figure>
<p>值得一提的是，如果App计划使用React Native进行部分模块功能的开发，那么在基础函数库选择方面需要考虑和React Native的依赖库的复用，这样可以减少引入React Native所增加的App大小，可以复用的函数库有：OkHttp、Fresco、jackson-core。</p>
<style type="text/css">
    p {
        text-indent: 2em; /*首行缩进*/
    }
</style></div><div class="tags"></div><div class="post-nav"><a href="/2017/12/04/Android-Senior-Plug-In/" class="pre">Android高级进阶笔记-Android插件框架机制</a><a href="/2017/11/29/Android-Senior-Code-Optimize/" class="next">Android高级进阶笔记-代码优化</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = '长桥の情书';
var disqus_identifier = '2017/12/02/Android-Senior-tech-stack/';
var disqus_title = 'Android高级进阶笔记-基于开源项目搭建属于自己的技术堆栈';
var disqus_url = 'http://yoursite.com/2017/12/02/Android-Senior-tech-stack/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//长桥の情书.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/17/html5-fkjava-char2/">疯狂HTML 5+CSS 3+JavaScript讲义笔记——2.HTML 5的常用元素与属性</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Never/">Never</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Error/">Error</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Empty/">Empty</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Timer/">Timer</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Interval/">Interval</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Range/">Range</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Defer/">Defer</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Create/">Create</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-RepeatWhen/">RepeatWhen</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//长桥の情书.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">长桥の情书.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>