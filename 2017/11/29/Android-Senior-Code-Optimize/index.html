<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android高级进阶笔记-代码优化 | 长桥の情书</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android高级进阶笔记-代码优化</h1><a id="logo" href="/.">长桥の情书</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android高级进阶笔记-代码优化</h1><div class="post-meta">Nov 29, 2017</div><a data-disqus-identifier="2017/11/29/Android-Senior-Code-Optimize/" href="/2017/11/29/Android-Senior-Code-Optimize/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>代码级别的优化是最基本的能力，每个开发人员都应该不断提高自己的编码能力，从而写出高效的代码。根据Android官方的建议，编写高效代码的两个基本准则如下：</p>
<ul>
<li>不要做冗余的工作；</li>
<li>尽量避免次数过多的内存分配操作。</li>
</ul>
<p>在这里要加上第三个准则：深入理解所用语言特性和系统平台的API，具体到Android开发，就是要熟练掌握Java语言，并对Android SDK 所提供的API了如指掌。</p>
<h3 id="1-数据结构的选择"><a href="#1-数据结构的选择" class="headerlink" title="1. 数据结构的选择"></a>1. 数据结构的选择</h3><p>正确的选择合适的数据结构是非常重要的，对Java常见的数据结构例如ArrayList和LinkedList、HashMap和HashSet等，需要做到对它们的联系与区别有较深入的理解，这样在变形代码中面临选择时才能做出正确的选择，下面以在Android中使用SparseArray代替HashMap为例进行说明。SparseArray是Android平台特有的稀疏数组的实现，它是Integer到Object的一个映射，在特定场合可用于替代HashMap<integer, <e="">&gt;，提高性能。它的核心实现是二分查找法。</integer,></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This is Arrays.binarySearch(), but doesn't dp any argument validation.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> size, <span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> hi = size - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> midVal = array[mid];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (midVal &lt; value) &#123;</div><div class="line">            lo = mid + <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; value) &#123;</div><div class="line">            hi = mid - <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> mid; <span class="comment">// value found</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ~lo; <span class="comment">// value not present</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SparseArray家族目前有以下四类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用于替代HashMap&lt;Integer, Boolean&gt; booleanMap = new HashMap&lt;Integer, Boolean&gt;();</span></div><div class="line">SparseBooleanArray booleanArray = <span class="keyword">new</span> AparseBooleanArray();</div><div class="line"></div><div class="line"><span class="comment">// 用于替代HashMap&lt;Integer, Integer&gt; integerMap = new HashMap&lt;Integer, Integer&gt;();</span></div><div class="line">SparseIntArray intArray = <span class="keyword">new</span> SparseIntArray();</div><div class="line"></div><div class="line"><span class="comment">// 用于替代HashMap&lt;Integer, Long&gt; longMap = new HashMap&lt;Integer, Long&gt;();</span></div><div class="line">SparseLongArray longArray = <span class="keyword">new</span> SparseLongArray();</div><div class="line"></div><div class="line"><span class="comment">// 用于替代HashMap&lt;Integer, String&gt; stringMap = new HashMap&lt;Integer, String&gt;();</span></div><div class="line">SparseArray&lt;String&gt; stringArray = <span class="keyword">new</span> SparseArray&lt;String&gt;();</div></pre></td></tr></table></figure>
<p>需要注意以下几点：</p>
<ul>
<li>SparseArray不是线程安全的；</li>
<li>由于要二分查找，因此，SparseArray会对插入的数据按照Key值大小顺序插入；</li>
<li>SparseArray对删除做了优化，它并不会立即删除这个元素，而是通过设置标识位（DELETED）的方式，后面尝试使用。</li>
</ul>
<p>在Android工程中运行Lint进行静态代码分析，会有一个名为AndroidLintUseSparseArrays的检查项，如果违规，它会提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HashMap can be replaced with SparseArray</div></pre></td></tr></table></figure>
<p>这样可以很轻松地找到工程中可以优化的地方。</p>
<h3 id="2-Handler和内部类的正确用法"><a href="#2-Handler和内部类的正确用法" class="headerlink" title="2. Handler和内部类的正确用法"></a>2. Handler和内部类的正确用法</h3><p>Android代码中涉及线程键通信的地方经常会使用Handler，典型的代码结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 可能引入内存泄漏的用法</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mLeakyHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用Android Link分析这段代码，会违反检查项AndroidLintHandlerLeak，得到如下提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">This Handler class should be static or leaks might occur.</div></pre></td></tr></table></figure>
<p>那么产生内存泄漏的原因可能是什么呢？我们知道，Handler是和Looper已经MessageQueue一起工作的，在Android中，一个应用启动后，系统会默认创建一个为主线程服务的Looper对象，这个Looper对象用于处理主线程的所有Message对象，它的生命周期贯穿于应用的整个生命周期。在主线程中使用Handler都会默认绑定到这个Looper对象。在主线程中创建Handler对象时，它会立即关联主线程Looper对象的MessageQueue，这时发送到MessageQueue中的Message对象都会持有这个Handler对象的引用，这样在Looper处理消息时才能回调Handler的handleMessage()方法。因此，如果Message还没有被处理完成，那么Handler对象也就不会被垃圾回收。</p>
<p>在上面的代码中，将Handler的实例声明为HandlerActivity的内部类，而在Java语言中，非静态内部匿名类会持有外部类的一个隐式引用，这样就可能会导致外部类无法被回收。因此，最终由于MessageQueue中的Message还没处理完成，就会持有Handler对象的引用，而非静态的Handler对象会持有HandlerActivity的引用，这个Activity无法被回收，从而导致内存泄漏。</p>
<p>一个明显的会引入内存泄漏的例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 可能引入内存泄漏的用法</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mLeakyHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">        <span class="comment">// 延迟5分钟发送消息</span></div><div class="line">        mLeakyHandler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function">pubilc <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">/**</span></div><div class="line"><span class="comment">                 * ...</span></div><div class="line"><span class="comment">                 */</span></div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">5</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于消息延迟5分钟发送，因此，当用户进入这个Activity并退出后，在消息发送并处理完成之前，这个Activity是不会被系统回收的（系统内存不足的情况例外）。</p>
<p>这里有两个解决方案：</p>
<ul>
<li>在子线程中使用Handler，这时需要开发者自己创建一个Looper对象，这个Looper对象的生命周期同一般的Java对象，因此这种用法没有问题；</li>
<li>将Handler声明为静态内部类，前面说过，静态内部类不会持有外部类的引用，因此，也不会引起内存泄漏，经典用法如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 声明一个静态的Handler内部类，并持有外部类的弱引用</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> calss InnerHandler extends Handler &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;HandlerActivity&gt; mActivity;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerHandler</span><span class="params">(HandlerActivity activity)</span> </span>&#123;</div><div class="line">            mActivity = <span class="keyword">new</span> WeakReference&lt;HandlerActivity&gt;(activity);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            HandlerActivity activity = mActivity.get();</div><div class="line">            <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// ...</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InnerHandler mHandler = <span class="keyword">new</span> InnerHandler(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 静态的匿名内部类不会持有外部类的引用</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable sRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">/* ... */</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">        <span class="comment">// 延迟5分钟发送消息</span></div><div class="line">        mHandler.postDelayed(sRunnable, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">5</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-正确使用Context"><a href="#3-正确使用Context" class="headerlink" title="3. 正确使用Context"></a>3. 正确使用Context</h3><p>Context应该是每个入门Android开发的程序员第一个接触到的概念，它代表当前的上下文环境，可以用来实现很多功能的调用，语句如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取资源管理器对象，进而可以访问到例如string、color等资源</span></div><div class="line">Resources resources = context.getResources();</div><div class="line"></div><div class="line"><span class="comment">// 启动指定的Activity</span></div><div class="line">context.startActivity(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, MainActivity.class));</div><div class="line"></div><div class="line"><span class="comment">// 获取各种系统服务</span></div><div class="line">TelephonyManager tm = (TelephonyManager) context.getSystemService(</div><div class="line">        Context.TELEPHONY_SERVICE);</div><div class="line"></div><div class="line"><span class="comment">// 获取系统文件目录</span></div><div class="line">File internalDir = context.getCacheDir();</div><div class="line">File externalDir = context.getExternalCacheDir();</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure>
<p>可见，正确使用Context的概念是很重要的，虽然应用开发中随处可见Context的使用，但并不是所有的Context实例都具备相同的功能，在使用上面需要区别对待，否则很可能会引入问题。首先来总结一下Context的种类。</p>
<h4 id="3-1-Context的种类。"><a href="#3-1-Context的种类。" class="headerlink" title="3.1 Context的种类。"></a>3.1 Context的种类。</h4><p>根据Context依托的组件以及用途不同，我们可以将Context分为以下几种：</p>
<ul>
<li><strong>Application</strong><br>  Android应用中的默认单例类，在Activity或者Service中通过<code>getApplication()</code>就可以获取到这个单例，通过<code>context.getApplicationContext()</code>可以获取到应用全局唯一的Context实例；</li>
<li><strong>Activity/Service</strong><br>  这两个类都是ContextWrapper的子类，在这两个类中可以通过<code>getBaseContext()</code>获取到它们的Context实例，不同的Activity或Service实例，它们的Context都是独立的，不会重复；</li>
<li><strong>BroadcastReceiver</strong><br>  和Activity以及Service不同，BroadcastReceiver本身并不是Context的子类，而是在回调函数<code>onReceive()</code>中由Android框架传入一个Context的实例。系统传入的这个实例是经过功能裁剪的，它不能调用<code>registerReceiver()</code>以及<code>bindService()</code>这两个方法；</li>
<li><strong>ContentProvider</strong><br>  同样的，ContextProvider也不是Context的子类，但是在创建时系统会传入一个Context实例，这样在ContentProvider中可以通过调用<code>getContext()</code>方法获取。如果ContentProvider和调用者处于同一进程中，那么<code>getContext()</code>将返回应用全局唯一的Context实例，如果是其它进程调用ContentProvider，那么ContentProvider将持有自身所在进程的Context实例。</li>
</ul>
<h4 id="3-2-错误使用Context导致的内存泄漏"><a href="#3-2-错误使用Context导致的内存泄漏" class="headerlink" title="3.2 错误使用Context导致的内存泄漏"></a>3.2 错误使用Context导致的内存泄漏</h4><p>错误地使用Context可能会导致内存泄漏，典型的例子是在实现单例模式时使用Context，如下代码是可能会导致内存泄漏的单例实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Context mContext;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance sInstance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        mContext = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</div><div class="line">            sInstance = <span class="keyword">new</span> SingleInstance(context);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果使用者调用getInstance()时传入的Context是一个Activity或者Service实例，那么在应用退出之前，由于单例一直存在，会导致对应的Activity或者Service被单例引用，从而不会被回收，Activity或者Service中关联的其他View或者数据结构对象也不会被释放，从而导致内存泄漏。正确的做法是使用Application Context，因为它是应用唯一的，而且生命周期是跟应用一直的，正确的单例实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Context mContext;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance sInstance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        mContext = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">pubilc <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</div><div class="line">            sInstance = <span class="keyword">new</span> SingleInstance(context.getApplicationContext()); <span class="comment">// 这一句是关键</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-3-不同Context的对比"><a href="#3-3-不同Context的对比" class="headerlink" title="3.3 不同Context的对比"></a>3.3 不同Context的对比</h4><p>不同组件中的Context能提供的功能不尽相同，总结起来，如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">功能</th>
<th style="text-align:center">Application</th>
<th style="text-align:center">Activity</th>
<th style="text-align:center">Service</th>
<th style="text-align:center">BroadcastReceiver</th>
<th style="text-align:center">ContentProvider</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">显示Dialog</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td style="text-align:left">启动Activity</td>
<td style="text-align:center">NO[1]</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO[1]</td>
<td style="text-align:center">NO[1]</td>
<td style="text-align:center">NO[1]</td>
</tr>
<tr>
<td style="text-align:left">实现Layout Inflation</td>
<td style="text-align:center">NO[2]</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO[2]</td>
<td style="text-align:center">NO[2]</td>
<td style="text-align:center">NO[2]</td>
</tr>
<tr>
<td style="text-align:left">启动Service</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:left">绑定Service</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td style="text-align:left">发送Broadcast</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:left">注册Broadcast</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO[3]</td>
</tr>
<tr>
<td style="text-align:left">加载资源Resources</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
</tbody>
</table>
<p>其中NO[1]标记表示对应的组件并不是真的不可以启动Activity，而是建议不要这么做，因为这些组件会在新的Task中创建Activity。</p>
<p>NO[2]标记也是表示不建议这么做，因为在非Activity中进行Layout Inflation，会使用系统默认的主题，而不是应用中设置的主题。</p>
<p>NO[3]标记表示在 Android 4.2 及以上的系统上，如果注册的BroadcastReceiver是null时是可以的，用来获取sticky广播的当前值。</p>
<h3 id="4-Java的四种引用方式"><a href="#4-Java的四种引用方式" class="headerlink" title="4. Java的四种引用方式"></a>4. Java的四种引用方式</h3><p>掌握Java的四种引用类型对于写出内存使用良好的应用是很关键的，同时它也是技术面试中经常出现的题目，属于语言基础。</p>
<ul>
<li>强引用<br>  Java里面最广泛使用的一种，也是对象默认的引用类型。如果一个对象具有强引用，那么垃圾回收器是不会对它进行回收操作的，当内存空间不足时，Java虚拟机将会抛出OutOfMemoryError错误，这时应用将会终止运行。</li>
<li>软引用<br>  一个对象如果只有软引用，那么当内存空间充足时，垃圾回收器不会对它进行回收操作，只有当内存空间不足时，这个对象才会被回收。软引用可以用来实现内存敏感的高速缓存，如果配合引用队列（ReferenceQueue）使用，当软引用指向的对象呗垃圾回收器回收后，Java虚拟机将会把这个软引用加入到与之关联的引用队列中。</li>
<li>弱引用<br>  在面试过程中，很多面试者经常会将弱引用和软引用这两者搞混，其实从名字上可以看出，弱引用是比软引用更弱的一种引用类型，只有弱引用指向的对象的生命周期更短，当垃圾回收期扫描到只有弱引用的对象时，不论当前内存空间是否不足，都会对弱引用对象进行回收。弱引用也可以和一个引用队列配合使用，当弱引用指向的对象被回收后，Java虚拟机会将这个弱引用加入到与之关联的引用队列中。</li>
<li>虚引用<br>  和软引用和弱引用不同，虚引用并不会对所指向的对象生命周期产生任何影响，也就是对象还是会按照它原来的方式呗垃圾回收器回收，虚引用本质上只是一个标记作用，主要用来跟踪对象被垃圾回收的活动，虚引用必须和引用队列配合使用，当对象被垃圾回收时，如果存在虚引用，那么Java虚拟机会将这个虚引用加入到与之关联的引用队列中。</li>
</ul>
<p>获取大多数人对于将软引用、弱引用、虚引用加入到引用队列之后有什么作用很疑惑，面试过程中也发现很多人知道四种引用的定义，但对于引用队列的作用却一无所知，</p>
<h3 id="5-其他代码微优化"><a href="#5-其他代码微优化" class="headerlink" title="5. 其他代码微优化"></a>5. 其他代码微优化</h3><h4 id="5-1-避免创建非必要的对象"><a href="#5-1-避免创建非必要的对象" class="headerlink" title="5.1 避免创建非必要的对象"></a>5.1 避免创建非必要的对象</h4><p>对象的创建需要内存分配，对象的销毁需要垃圾回收，这些都会一定程度上影响到应用的性能。因此一般来说，最好是重用对象而不是在每次需要的时候去创建一个功能相同的新对象，特别是注意不要在循环中重复创建相同的对象。</p>
<h4 id="5-2-对常量使用static-final-修饰"><a href="#5-2-对常量使用static-final-修饰" class="headerlink" title="5.2 对常量使用static final 修饰"></a>5.2 对常量使用static final 修饰</h4><p>对于基本数据类型和String类型的常量，建议使用static final修饰，因为final类型的常量会在进入静态dex文件的域初始化部分，这时对基本数据类型和String类型常量的调用不会涉及类的初始化，而是直接调用字面量。</p>
<h4 id="5-3-避免内部的Getters-Setters"><a href="#5-3-避免内部的Getters-Setters" class="headerlink" title="5.3 避免内部的Getters/Setters"></a>5.3 避免内部的Getters/Setters</h4><p>在面向对象编程中，Getters/Setters的作用主要是对外屏蔽具体的变量定义，从而达到更好的封装性。但如果在类内部还使用Getters/Setters函数访问变量的话，会降低访问的速度。根据Android官方文档，在没有JIT（Just In Time）编译器时，直接访问变量的速度是调用Getter方法的3倍；在JIT编译时，直接访问变量的速度是调用Getter方法的7倍。当然如果应用中真的使用了ProGuard的话，那么ProGuard会对Getters/Setters进行内联操作，从而达到直接访问的效果。</p>
<h4 id="5-4-代码的重构"><a href="#5-4-代码的重构" class="headerlink" title="5.4 代码的重构"></a>5.4 代码的重构</h4><p>代码的重构是意向长期的持之以恒的工作，需要依靠团队中每一个成员来维护代码库的高质量，如何有效的进行代码重构，除了需要对你所在的项目有较深入的理解外，还需要一定的方法论指导，强烈推荐《重构-改善既有代码的设计》和《代码整洁之道》这两本书。</p>
<style type="text/css">
    p {
        text-indent: 2em; /*首行缩进*/
    }

    table td: nth-child(1) {
        white-space: nowrap;
    }
    table th {
        white-space: nowrap;
    }
</style>
</div><div class="tags"></div><div class="post-nav"><a href="/2017/12/02/Android-Senior-tech-stack/" class="pre">Android高级进阶笔记-基于开源项目搭建属于自己的技术堆栈</a><a href="/2017/11/28/Android-Senior-Animation/" class="next">Android高级进阶笔记-动画机制</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = '长桥の情书';
var disqus_identifier = '2017/11/29/Android-Senior-Code-Optimize/';
var disqus_title = 'Android高级进阶笔记-代码优化';
var disqus_url = 'http://yoursite.com/2017/11/29/Android-Senior-Code-Optimize/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//长桥の情书.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/17/html5-fkjava-char2/">疯狂HTML 5+CSS 3+JavaScript讲义笔记——2.HTML 5的常用元素与属性</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Never/">Never</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Error/">Error</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Empty/">Empty</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Timer/">Timer</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Interval/">Interval</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Range/">Range</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Defer/">Defer</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Create/">Create</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-RepeatWhen/">RepeatWhen</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//长桥の情书.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">长桥の情书.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>