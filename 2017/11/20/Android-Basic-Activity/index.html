<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android开发艺术探索笔记-Activity生命周期和启动模式 | 长桥の情书</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android开发艺术探索笔记-Activity生命周期和启动模式</h1><a id="logo" href="/.">长桥の情书</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android开发艺术探索笔记-Activity生命周期和启动模式</h1><div class="post-meta">Nov 20, 2017</div><a data-disqus-identifier="2017/11/20/Android-Basic-Activity/" href="/2017/11/20/Android-Basic-Activity/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>Activity作为Android四大组件之首，是使用最为频繁的一种组件。正常情况下，除了Window、Dialog和Toast等特殊界面，我们能见到的界面只有Activity。但是Activity在异常情况下的生命周期是十分微妙的，Activity的启动模式和形形色色的Flags更是让人摸不着头脑，就连隐式启动Activity中也有着复杂的Intent匹配过程，下面就来一一解开这些问题的神秘面纱。</p>
<h3 id="1-Activity的生命周期"><a href="#1-Activity的生命周期" class="headerlink" title="1. Activity的生命周期"></a>1. Activity的生命周期</h3><p>Activity的生命周期分为两种：一种是正常情况下的生命周期，另一种是异常情况下的生命周期。正常情况下的生命周期是指在用户参与的情况下Activity所经历的生命周期的改变；而异常情况下的生命周期则是指Activity被系统回收或者由于当前设备Configuration改变从而导致的Activity被销毁重建。异常情况下生命周期的关注点与正常情况下略有不同。</p>
<h4 id="1-1-Activity的四种状态"><a href="#1-1-Activity的四种状态" class="headerlink" title="1.1 Activity的四种状态"></a>1.1 Activity的四种状态</h4><p>Activity整个生命周期中存在四种状态：</p>
<ol>
<li><strong>running</strong>：处于<strong>活动状态</strong>，用户可以与Activity进行交互。这时Activity处于栈顶；</li>
<li><strong>paused</strong>：Activity<strong>失去焦点</strong>，栈顶被非全屏或透明的Activity所占据；</li>
<li><strong>stoped</strong>：Activity<strong>不可见</strong>，Activity被另一个Activity所完全覆盖，但是它的内存信息、成员变量等数据都还存在；</li>
<li><strong>killed</strong>：Activity<strong>已经被系统回收</strong>，所保存的数据都已经不再存在。</li>
</ol>
<h4 id="1-2-正常情况下的声明周期"><a href="#1-2-正常情况下的声明周期" class="headerlink" title="1.2 正常情况下的声明周期"></a>1.2 正常情况下的声明周期</h4><p>正常情况下，Activity会经历如下生命周期：</p>
<ol>
<li><strong>onCreate()</strong>：<strong>表示Activity正在被创建</strong>。这是生命周期的第一个方法。在这个方法中，我们可以做一些初始化工作，如setContentView()加载界面布局资源、初始化Activity所需数据等；</li>
<li><strong>onRestart()</strong>：<strong>表示Activity正在被重新启动</strong>。当这个Activity从不可见重新变成可见状态时，onRestart()方法会被调用。这种情形一般是用户行为导致的；</li>
<li><strong>onStart()</strong>：<strong>表示Activity正在被启动</strong>。这时Activity已经可见了，但是还不能和用户交互；</li>
<li><strong>onResume()</strong>：<strong>表示Activity已经可以进行交互了</strong>。</li>
<li><strong>onPause()</strong>：<strong>表示Activity正在停止</strong>。正常情况下，onPause()方法被调用后，onStop()方法就会被调用了，但是在特殊情况下，如果这个时候迅速的再回到这个Activity，那么onResume()会被调用，但是这种情况属于极端情况，用户很难重现这个场景。onPause()中可以做一些存储数据、停止动画等工作，但是注意不能太耗时，因为只有前一个Activity的onPause()执行完才会执行新Activity的onResume()方法；</li>
<li><strong>onStop()</strong>：<strong>表示Activity即将停止</strong>。这里可以做一些稍微重量级的回收工作，但是同样不能太耗时；</li>
<li><strong>onDestroy()</strong>：<strong>表示Activity即将被销毁</strong>。这是Activity生命周期中的最后一个回调，在这里，我们可以做一些回收工作和最终的资源释放。</li>
</ol>
<p>正常情况下，Activity的常用生命周期就只有上述7个，下图描述了Activity各生命周期的切换过程：</p>
<p><img src="https://github.com/QinHanSoft/BlogImages/blob/master/Activity_Lifecycle.png?raw=true" alt=""></p>
<p>针对一个特定的Activity，其生命周期分为以下几种情况：</p>
<ol>
<li>第一次启动时，回调顺序是：onCreate() -&gt; onStart() -&gt; onResume()；</li>
<li>当用户打开新的Activity或返回到桌面是，回调顺序是：onPause() -&gt; onStop()。这里有一种特殊情况，如果新的Activity是透明或非全屏的，那么当前Activity不会回调onStop()；</li>
<li>当用户再次返回到原Activity时，回调顺序是：onRestart() -&gt; onStart() -&gt; onResume()；</li>
<li>当用户按下back键返回时，回调顺序是：onPause() -&gt; onStop() -&gt; onDestroy()；</li>
<li>当Activity被系统回收后再次打开，生命周期回调过程和1一样，注意只是生命周期方法一样，不代表所有过程都一样；</li>
<li>从整个生命周期来说，onCreate()和onDestroy()是配对的，分别标识着Activity的创建和销毁，并且只能有一次调用；从Activity是否可见来看，onStart()和onStop()是配对的，随着用户的操作或设备的点亮与熄灭可能被调用多次；从Activity是否可交互来看，onResume()和onPause()是配对的，随着用户的操作或设备的点亮与熄灭可能被调用多次。</li>
</ol>
<h4 id="1-3-异常情况下的生命周期分析"><a href="#1-3-异常情况下的生命周期分析" class="headerlink" title="1.3 异常情况下的生命周期分析"></a>1.3 异常情况下的生命周期分析</h4><p>Activity除了受用户操作所导致的政策的生命周期方法调度外，还有一些异常情况，比如当资源相关的系统配置发生改变以及系统内存不足时，Activity就可能被杀死。下面我们具体分析这两种情况。</p>
<h5 id="1-3-1-情况1：资源相关的系统配置发生改变导致Activity被杀死并重新创建"><a href="#1-3-1-情况1：资源相关的系统配置发生改变导致Activity被杀死并重新创建" class="headerlink" title="1.3.1 情况1：资源相关的系统配置发生改变导致Activity被杀死并重新创建"></a>1.3.1 情况1：资源相关的系统配置发生改变导致Activity被杀死并重新创建</h5><p>比如说当前Activity处于竖屏状态，如果这时旋转屏幕，这样系统配置就发生了改变，在默认情况下，Activity就会被销毁并重新创建，当然我们也可以阻止系统重新创建我们的Activity。</p>
<p>默认情况下，如果我们的Activity不做特殊处理，那么当系统配置发生改变后，Activity就会被销毁并重建，生命周期如下图所示。<br><img src="https://github.com/QinHanSoft/BlogImages/blob/master/Activity_Lifecycle_exception.png?raw=true" alt=""></p>
<p>当系统配置发生改变后，Activity会被销毁，onPause()、onStop()、onDestroy()方法都会被调用，同时，由于Activity是在异常情况下终止的，系统会调用onSaveInstanceState()来保存当前Activity的状态。这个方法会在onStop()前被调用，但和onPause()没有既定的时序关系。这个方法只会出现在Activity被异常终止的情况下，正常情况系统不会调用这个方法。当Activity被重新创建后，系统会调用onRestoreInstanceState()方法，并且把Activity销毁时onSaveInstanceState()方法所保存的Bundle对象作为参数传递给onRestoreInstanceState()和onCreate()方法来判断Activity是否被重建了，如果被重建了，那么我们就可以取出之前保存的数据并恢复，从时序上来说，onRestoreInstanceState()方法在onStaet()之后调用。</p>
<p>在onSaveInstanceState()和onRestoreInstanceState()方法中，系统自动为我们做了一定的恢复工作。当Activity在异常情况下需要重新创建时，系统会默认为我们保存当前Activity的视图结构，并在Activity重启后为我们恢复这些数据，如文本框中用户输入的数据、ListView滚动的位置等，这些View相关的状态系统都能够默认为我们恢复。具体针对某一个特定的View系统能为我们恢复哪些数据，可以查看View的源码。和Activity一样，每个View都有onSaveInstanceState()和onRestoreInstanceState()这两个方法，看一下它们的具体实现，就能知道系统能够自动为每个View恢复哪些数据。</p>
<p>关于保存和恢复View层次结构，系统的工作流程是这样的：首先Activity被意外终止时，Activity会调用onSaveInstanceState()去保存数据，然后Activity会委托Window去保存数据，接着Window再委托它上面的顶级容器去保存数据。顶层容器是一个ViewGroup，一般来说它可能是DecorView。最后顶层容器再去一一通知它的子元素去保存数据，这样整个数据保存过程就结束了。可以发现，这是一种典型的委托思想，上层委托下层、父容器委托子元素去处理一件事情，这种思想在Android中有很多应用，比如View的绘制过程、事件分发等都是采用类似的思想。至于数据恢复过程也是类似的，这里不再赘述。下面举例说明，看看TextView保存了哪些数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Parcelable <span class="title">onSaveInstanceState</span><span class="params">()</span> </span>&#123;</div><div class="line">    Parcelable superState = <span class="keyword">super</span>.onSaveInstanceState();</div><div class="line"></div><div class="line">    <span class="comment">// Save state if we are forced to</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> freezesText = getFreezesText();</div><div class="line">    <span class="keyword">boolean</span> hasSelection = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span> start = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> end = -<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mText != <span class="keyword">null</span>) &#123;</div><div class="line">        start = getSelectionStart();</div><div class="line">        end = getSelectionEnd();</div><div class="line">        <span class="keyword">if</span> (start &gt;= <span class="number">0</span> || end &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// Or save state if there is a selection</span></div><div class="line">            hasSelection = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (freezesText || hasSelection) &#123;</div><div class="line">        SavedState ss = <span class="keyword">new</span> SavedState(superState);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (freezesText) &#123;</div><div class="line">            <span class="keyword">if</span> (mText <span class="keyword">instanceof</span> Spanned) &#123;</div><div class="line">                <span class="keyword">final</span> Spannable sp = <span class="keyword">new</span> SpannableStringBuilder(mText);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) &#123;</div><div class="line">                    removeMisspelledSpans(sp);</div><div class="line">                    sp.removeSpan(mEditor, mSuggestionRangeSpan);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ss.text = sp;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ss.text = mText.toString();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (hasSelection) &#123;</div><div class="line">            <span class="comment">// XXX Should also save the current scroll position!</span></div><div class="line">            ss.selStart = start;</div><div class="line">            ss.selEnd = end;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (isFocused() &amp;&amp; start &gt;= <span class="number">0</span> &amp;&amp; end &gt;= <span class="number">0</span>) &#123;</div><div class="line">            ss.frozenWithFocus = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ss.error = getError();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) &#123;</div><div class="line">            ss.editorState = mEditor.saveInsatnceState();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ss;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> superState;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以很容易的看出，TextView保存了自己的文本选中状态和文本内容，并且通过查看其onRestoreInstanceState()方法可以发现它确实恢复了这些数据。</p>
<h5 id="1-3-2-情况2：资源内存不足导致低优先级的Activity被杀死"><a href="#1-3-2-情况2：资源内存不足导致低优先级的Activity被杀死" class="headerlink" title="1.3.2 情况2：资源内存不足导致低优先级的Activity被杀死"></a>1.3.2 情况2：资源内存不足导致低优先级的Activity被杀死</h5><p>这种情况不好模拟，但是其数据存储和恢复过程和情况1完全一致。这里描述一下Activity的优先级，从高到低可分为如下三种：</p>
<ol>
<li>前台Activity：正在和用户交互的Activity，优先级最高；</li>
<li>可见非前台Activity：Activity可见但是不可与用户直接交互；</li>
<li>后台Activity：已经被暂停的Activity，优先级最低。</li>
</ol>
<p>当系统内存不足时，系统就会按照上述优先级去杀死目标Activity所在的进程，并在后续通过onSaveInstanceState()和onRestoreInstanceState()来存储和恢复数据。如果一个进程没有四大组件在执行，那么这个进程将很快被系统杀死。</p>
<p>上面分析了系统的数据存储和恢复机制，当系统配置发生改变后，Activity会被重新创建，那么有没有办法不重新创建呢？答案是有的。系统配置中有很多内容，如果当某项内容发生改变后，我们不想系统重新创建Activity，可以给Activity知道configChanges属性，比如不想让Activity在屏幕选择的时候重新创建，就可以给configChanges属性添加orientation这个值，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android:configChanges="orientation"</div></pre></td></tr></table></figure>
<p>如果我们想指定多个值，可以用“|”链接起来，如<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android:configChanges="orientation|keyboardHidden"</div></pre></td></tr></table></figure></p>
<p>系统配置中项目非常多，含义如下表：</p>
<style>
    table td: nth-child(1) {
        white-space: nowrap;
    }
    table th {
        white-space: nowrap;
    }
</style>

<table>
<thead>
<tr>
<th style="text-align:left">项目&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">mcc</td>
<td style="text-align:left">SIM卡唯一标识IMSI（国际移动用户识别码）中的国家代码，由三位数字组成，中国为460。此项标识mcc代码发送了改变</td>
</tr>
<tr>
<td style="text-align:left">mnc</td>
<td style="text-align:left">SIM卡唯一标识IMSI（国际移动用户识别码）中的运营商代码，由两位数字组成，中国移动TD系统为00，中国联通为01，中国电信为03。此项标识mnc发生改变</td>
</tr>
<tr>
<td style="text-align:left">locale</td>
<td style="text-align:left">设备的本地位置发生了改变，一般指切换了系统语言</td>
</tr>
<tr>
<td style="text-align:left">touchscreen</td>
<td style="text-align:left">触摸屏发生了改变，这个很费解，正常情况下无法发生，可以忽略它。</td>
</tr>
<tr>
<td style="text-align:left">keyboard</td>
<td style="text-align:left">键盘类型发生了改变，比如用户使用了外插键盘</td>
</tr>
<tr>
<td style="text-align:left">keyboardHidden</td>
<td style="text-align:left">键盘的可访问性发生了变化，比如用户调出了键盘</td>
</tr>
<tr>
<td style="text-align:left">navigation</td>
<td style="text-align:left">系统导航方式发生了改变，很难发生，可以忽略</td>
</tr>
<tr>
<td style="text-align:left">screenLayout</td>
<td style="text-align:left">屏幕布局发生了改变，可能是用户激活了其他的显示设备</td>
</tr>
<tr>
<td style="text-align:left">fontScale</td>
<td style="text-align:left">系统字体缩放比例发生了改变，可能是用户选择了新的字号</td>
</tr>
<tr>
<td style="text-align:left">uiMode</td>
<td style="text-align:left">用户界面模式发生了改变，如开启了夜间模式（API 8添加）</td>
</tr>
<tr>
<td style="text-align:left">orientation</td>
<td style="text-align:left">屏幕方向发生了改变，这个是最常用的，如旋转了屏幕</td>
</tr>
<tr>
<td style="text-align:left">screenSize</td>
<td style="text-align:left">屏幕的尺寸信息发生了改变，当旋转屏幕时，屏幕尺寸会发生变化，它和编译选项有关，当编译选项的minSdkVersion和targetSdkVersion均低于13时，此选项不会导致Activity重启，否则会导致Activity重启（API 13添加）</td>
</tr>
<tr>
<td style="text-align:left">smallestScreenSize</td>
<td style="text-align:left">设备的物理屏幕尺寸发生改变，它和屏幕的方向没有关系，进阶表示在实际的物理屏幕的尺寸改变的时候发生，如用户切换到了外部的显示设备，这个选项和screenSize一样，当编译选项中的minSdkVersion和targetSdkVersion均低于13时，它不会导致Activity重启，否则会导致Activity重启（API 13添加）</td>
</tr>
<tr>
<td style="text-align:left">layoutDirection</td>
<td style="text-align:left">布局方向发生变化，这个属性用的比较少，正常情况下无需修改布局的layoutDirection属性（API 17添加）</td>
</tr>
</tbody>
</table>
<p>从上表可知，如果没有在Activity的configChanges属性汇总指定该选项的话，当配置发生改变后就会导致Activity重新创建。上表中项目很多，但是我们常用的只有locale、orientation和keyboardHidden这三个。需要注意的是screenSize和smallestScreenSize这两个比较特殊，它们的行为和编译选项有关而和运行环境无关。只需要在Androidmenifest.xml中加入Activity的声明即可，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">users-sdk</span></span></div><div class="line"><span class="tag">    <span class="attr">android:minSdkVersion</span>=<span class="string">"8"</span></span></div><div class="line"><span class="tag">    <span class="attr">android:targetSdkVersion</span>=<span class="string">"19"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">activity</span></span></div><div class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.qin.demo.MainActivity"</span></span></div><div class="line"><span class="tag">    <span class="attr">android:configChanges</span>=<span class="string">"orientation|screenSize"</span></span></div><div class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> &gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onConfigurationChanged(newConfig);</div><div class="line">    Log.d(TAG, <span class="string">"onConfigurationChanged, newOrientation:"</span> + newConfig.orientation);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-4-问题"><a href="#1-4-问题" class="headerlink" title="1.4 问题"></a>1.4 问题</h4><ol>
<li>onStart()和onResume()、onPause()和onStop()从描述上看来差不多，那么它们有什么实质上的不同呢？<br> 首先从实际使用过程来说，onStart()和onResume()、onPause()和onStop()看起来的确差不多，甚至我们可以只保留其中一对。经过上面的分析，我们知道这两个配对的回调分别表示不同的意义，onStart()和onStop()是从Activity是否可见来回调的，而onResume()和onPause()是从Activity是否可交互来回调的，它们分别代表了Activity的不同状态，除了这种区别，在实际使用中没有其他明显区别。</li>
<li><p>假设当前Activity为A，这时用户打开一个新的Activity B，那么B的onResume()和A的onPause()哪个先执行呢？<br> 这个问题可以从Android源码中得到解释，Activity的启动过程的源码十分复杂，设计Instrumentation、ActivityThread和ActivityManagerService（AMS）。简单理解，启动Activity的请求会有Instrumentation来处理，然后它通过Binder想AMS发请求，AMS内部维护了一个ActivityStack并复杂栈内的Activity的状态同步，AMS通过ActivityThread去同步Activity的状态从而完成生命周期方法掉调用。在ActivityStack中的resumeTopActivityInnerLocked()方法中，有以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// We need to start pausinng the current activity so the top one</span></div><div class="line"><span class="comment">// can be resumed...</span></div><div class="line"><span class="keyword">boolean</span> dontWaitForPause = (next.info.flags&amp;ActivityInfo.FLAG_RESUME_WHILE_PAUSING) != <span class="number">0</span>;</div><div class="line"><span class="keyword">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, <span class="keyword">true</span>, dontWaitForPause);</div><div class="line"><span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (DEGUG_STATES) Slog.d(TAG, <span class="string">"resumeTopActivityLocked: Pausing "</span> + mResumedActivity);</div><div class="line">    pausing |= startPausingLocked(userLeaving, <span class="keyword">false</span>, <span class="keyword">true</span>, dontWaitForPause);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 从上述代码可以看出，在新Activity启动之前，栈顶的Activity需要先onPause()后，新Activity才能启动。最终，在ActivityStackSupervisor中的realStartActivityLocked()方法会调用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r.appToken,</div><div class="line">        System.identityHashCode(r), r.info, <span class="keyword">new</span> Configuration(mService.mConfiguration),</div><div class="line">        r.compat, r.launchedFromPackage, r.task.voiceInteractor, app.repProcState,</div><div class="line">        r.icicle, r.presistentState, results, newIntents, !andResume,</div><div class="line">        mService.isNextTransitionForward(), profilerInfo);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个app.thread的类型是IApplicationThread，而IApplicationThread的具体实现是ActivityThread中的ApplicationThread。所以这段代码实际上调到了ActivityThread中，即ApplicationThread的scheduleLaunchActivity()方法，而scheduleLaunchActivity()方法最终会完成新Activity的onCreate()、onStart()、onPause()的调用过程。因此，可以得出结论，是旧的Activity的onPause()方法先调用，然后新Activity再启动。</p>
<h3 id="2-Activity的启动模式"><a href="#2-Activity的启动模式" class="headerlink" title="2. Activity的启动模式"></a>2. Activity的启动模式</h3><h4 id="2-1-Activity的LaunchMode"><a href="#2-1-Activity的LaunchMode" class="headerlink" title="2.1 Activity的LaunchMode"></a>2.1 Activity的LaunchMode</h4><p>在默认情况下，当我们多次启动同一个Activity的时候，系统会创建多个实例并一一放入任务栈中，当我们点击back键，这些Activity就会一一回退。任务栈是一种LIFO的栈结构，当栈中没有任何Activity的时候，系统就会回收这个任务栈。</p>
<p>Android提供了启动模式来修改系统的默认行为，目前有四种启动模式：standard、singleTop、singleTask和singleInstance，下面一一介绍它们的含义：</p>
<ol>
<li><p>standard<br> 标准模式，也是系统的默认模式。每次启动一个Activity都会创建一个新的实例。被创建的实例符合正常情况下Activity的生命周期。这是一种典型的多实例实现，一个任务栈中可以有多个实例，每个实例也可以属于不同的任务栈。在这种模式下，谁启动了这个Activity，这个Activity就运行在启动它的那个Activity所在的栈中。当我们用ApplicationContext去启动standard模式的Activity时会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">E/AndroidRuntime(674):android.util.AndroidRuntimeException:Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</div></pre></td></tr></table></figure>
<p> 这是因为standard模式的Activity默认会进入启动它的Activity所属的任务栈中，但是非Activity类型的Context并没有所谓的任务栈。解决这个问题的方法是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就会为它创建一个新的任务栈，这时候Activity实际上是以singleTask模式启动的；</p>
</li>
<li>singleTop<br> 栈顶复用模式。这种模式下，如果新的Activity已经位于任务栈的栈顶，那么Activity不会被重新创建，同时它的onNewIntent()方法会被回调，通过此方法的参数我们可以取出当前请求的信息。这个Activity的onCreate()、onStart()不会被系统调用，因为它并没有发生改变。如果新Activity的实例已存在但是不位于栈顶，那么新Activity仍然会被重新创建。</li>
<li>singleTask<br> 栈内复用模式。这是一种单实例模式，在这种模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，和singleTop一样，系统也会回调其onNewIntent()方法。同时，由于singleTask默认具有clearTop的效果，会导致位于这个Activity实例之上的所有Activity实例全部出栈。</li>
<li>singleInstance<br> 单实例模式。这是一种加强的singleTask模式，除了具有singleTask模式的所有特性外，还加强了一点：此模式的Activity只能单独位于一个任务栈中。</li>
</ol>
<h4 id="2-2-Activity的Flags"><a href="#2-2-Activity的Flags" class="headerlink" title="2.2 Activity的Flags"></a>2.2 Activity的Flags</h4><p>Activity的Flags有很多，这里主要分析一些比较常用的。标记位的作用很多，有的标记位可以设定Activity的启动模式，如FLAG_ACTIVITY_NEW_TASK和FLAG_ACTIVITY_SINGLE_TOP等；有的标记位可以影响Activity的运行状态，如FLAG_ACTIVITY_CLEAR_TOP和FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS等。下面介绍几种比较常用的标记位，大部分情况下，我们不需要为Activity指定标记位，因此，对于标记位理解即可。</p>
<ul>
<li><strong>FLAG_ACTIVITY_NEW_TASK</strong><br>  为Activity指定“singleTask”启动模式，效果和在XML中指定该启动模式相同；</li>
<li><strong>FLAG_ACTIVITY_SINGLE_TOP</strong><br>  为Activity指定“singleTop”启动模式，效果和在XML中指定该启动模式相同；</li>
<li><strong>FLAG_ACTIVITY_CLEAR_TOP</strong><br>  具有此标记位的Activity，在启动时，在同一任务栈的所有位于它上面的Activity都要出栈。这个模式一般需要和FLAG_ACTIVITY_NEW_TASK配合使用，在这种情况下，被启动的Activity的实例如果已经存在，那么系统就调用它的onNewIntent()。如果被启动的Activity采用standard模式启动，那么它连同它之上的Activity都要出栈，系统会创建新的Activity实例并压入栈顶；</li>
<li><strong>FLAG_ACTIVITY_EXCLUDE_FROM_RECUNTS</strong><br>  具有这个标记位的Activity不会出现在历史Activity的列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较用于，它等同于在XML中声明Activity的属性<code>android:excledeFromRecents=&quot;true&quot;</code>。</li>
</ul>
<h3 id="3-IntentFilter的匹配规则"><a href="#3-IntentFilter的匹配规则" class="headerlink" title="3. IntentFilter的匹配规则"></a>3. IntentFilter的匹配规则</h3><p>启动Activity分为两种方式：显式调用和隐式调用。显式调用需要明确的指定被启动对象的组件信息，包括包名和类名，而隐式调用则不需要需要明确指定组件信息。隐式调用需要Intent能够匹配目标组件的IntentFilter中所设置的过滤信息，如果不匹配将无法启动目标Activity。IntentFilter中的过滤信息有action、category、data，为了匹配过滤列表，需要同时匹配过滤列表中的这三个信息，否则匹配失败。一个过滤列表中的action、categroy和data可以有多个，所有的action、category和data分别构成不同类别，同一类别的信息共同约束当前类别的匹配过程。只有一个Intent同时匹配action类别、category类别、data类别才算完全匹配，只有完全匹配才能成功启动Activity。一个Activity可以有多个intent-filter，一个Intent只要能匹配任何一组intent-filter即可成功启动对应的Activity，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"ShareActivity"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- This activity handles "SENDS" actions with text data --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"text/plain"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- This activity also handles "SENDS" and "SEND_MULTIPLE" with media data --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND_MULTIPLE"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"application/vnd.google.panorama360+jpg"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"image/*"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"video/*"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure>
<p>下面详细分析各种属性的匹配规则。</p>
<h4 id="3-1-action的匹配规则"><a href="#3-1-action的匹配规则" class="headerlink" title="3.1 action的匹配规则"></a>3.1 action的匹配规则</h4><p>action是一个字符串，系统预定义了一些action，同时我们也可以在应用中定义自己的action。action的匹配规则是Intent中的action必须能够和过滤规则中的action匹配，这里说的匹配是指action的字符串值完全一样。一个过滤规则可以由多个action，那么只要Intent中的action能够和过滤规则中的任何一个action相同即可匹配成功。action区分大小写，大小写不同字符串相同的action会匹配失败。</p>
<h4 id="3-2-category的匹配规则"><a href="#3-2-category的匹配规则" class="headerlink" title="3.2 category的匹配规则"></a>3.2 category的匹配规则</h4><p>category是一个字符串，系统与定义了一些category，同时我们也可以在应用中定义自己的category。category的匹配规则和action不同，它要求Intent如果含有category，那么所有的category都必须和过滤规则中的其中一个category相同，就是说，Intent中如果出现了category，不管有几个category，每个category都必须是过滤规则中已经定义了的category，简单来说，就是Intent中的category必须都是intent-filter中定义过的，才能够匹配成功。Intent中也可以没有category，如果没有category的话，这个Intent仍然可以匹配成功。为什么不设置category也可以匹配呢？原因是系统在调用startActivity()或者startActivityForResult()的时候会默认为Intent加上<code>android.intent.category.DEFAULT</code>这个category，所以为了我们的Activity能够接受隐式调用，就必须在intnet-filter中指定这个category。</p>
<h4 id="3-3-data的匹配规则"><a href="#3-3-data的匹配规则" class="headerlink" title="3.3 data的匹配规则"></a>3.3 data的匹配规则</h4><h5 id="3-3-1-data的数据格式"><a href="#3-3-1-data的数据格式" class="headerlink" title="3.3.1 data的数据格式"></a>3.3.1 data的数据格式</h5><p>data的匹配规则和action类似，如果过了规则中定义了data，那么Intent中必须也要定义可匹配的data。在介绍data的匹配规则之前，要先了解一下data的结构。语法如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"string"</span></span></div><div class="line"><span class="tag">    <span class="attr">android:host</span>=<span class="string">"string"</span></span></div><div class="line"><span class="tag">    <span class="attr">android:port</span>=<span class="string">"string"</span></span></div><div class="line"><span class="tag">    <span class="attr">android:path</span>=<span class="string">"string"</span></span></div><div class="line"><span class="tag">    <span class="attr">android:pathPattern</span>=<span class="string">"string"</span></span></div><div class="line"><span class="tag">    <span class="attr">android:pathPrefix</span>=<span class="string">"string"</span></span></div><div class="line"><span class="tag">    <span class="attr">android:android:mimeType</span>=<span class="string">"string"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>data由两部分组成，分别是mimeType和URI。mimeType指媒体类型，如image/jpeg、audio/mpeg4-generic和video/*等，可以表示图片、文本、适配等不同的媒体格式，而URI中包含的数据比较多，下面是URI的结构：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">scheme</span>&gt;</span>://<span class="tag">&lt;<span class="name">host</span>&gt;</span>:<span class="tag">&lt;<span class="name">port</span>&gt;</span>/[<span class="tag">&lt;<span class="name">path</span>&gt;</span>|<span class="tag">&lt;<span class="name">pathPrefix</span>&gt;</span>|<span class="tag">&lt;<span class="name">pathPattern</span>&gt;</span>]</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">content:<span class="comment">//com.example.project:200/folder/subfolder/etc</span></div><div class="line">http:<span class="comment">//www.baidu.com:80/search/info</span></div></pre></td></tr></table></figure>
<ul>
<li>scheme：URI的模式，如http、file、content等，如果URI中没有指定scheme，那么正规URI的其他参数无效，也即URI是无效的；</li>
<li>host：URI的主机名，比如www.baidu.com，如果host未指定，那么正规URI中的其他参数无效，也即URI无效；</li>
<li>port：URI中的端口号，仅当URI中指定了scheme和host参数的时候，port参数才是有意义的；</li>
<li>path、pathPattern和pathPrefix：表述路径信息，其中path表示完整的路径信息，pathPattern也表示完整的路径信息，但是它里面可以包含通配符“*”，它表示0或任意多个字符，注意，由于正则表达式的规范，如果想表示真实的字符串，那么“*”要写成“\\*”，“\”要写成“\\\\”；pathPrefix表示路径的前缀信息。</li>
</ul>
<h5 id="3-3-2-data的匹配规则"><a href="#3-3-2-data的匹配规则" class="headerlink" title="3.3.2 data的匹配规则"></a>3.3.2 data的匹配规则</h5><p>data的匹配规则和action类似，它也要求Intent中必须含有data数据，并且data数据能够完全匹配过滤规则中的某一个data。下面分情况说明：</p>
<ol>
<li><p>规则如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"image/*"</span> /&gt;</span></div><div class="line">    ...</div><div class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div></pre></td></tr></table></figure>
<p> 这种规则指定了媒体类型为所有类型的图片，那么Intent中的mimeType属性必须为“image/*”才能匹配，这种情况下虽然过滤规则没有指定URI，但是却有默认值，URI的默认值为content和file。也就是说Intent中的URI部分的scheme必须为content或者file才能匹配，为了匹配这个规则，我们可以写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">intent.setDataAndType(Uri.parse(<span class="string">"file://abc"</span>), <span class="string">"image/png"</span>);</div></pre></td></tr></table></figure>
<p> 如果要为Intent指定完整的data，必须要调用setDataAndType()方法，不能先调用setData()再调用setType()，一万这两个方法会清除对方的值，这个看源码就很容易理解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">Intent <span class="title">setData</span><span class="params">(@Nullable Uri data)</span> </span>&#123;</div><div class="line">    mData = data;</div><div class="line">    mType = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">Intent <span class="title">setType</span><span class="params">(@Nullable String type)</span> </span>&#123;</div><div class="line">    mData = <span class="keyword">null</span>;</div><div class="line">    mType = type;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>规则如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"video/mpeg"</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">...</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"audio/mpeg"</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">...</span> /&gt;</span></div><div class="line">    ...</div><div class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div></pre></td></tr></table></figure>
<p> 这种规则指定了两组data规则，每个data都指定了完整的属性值，既有URI又有mimeType。为了匹配这种规则，我们可以使用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">intent.setDataAndType(Uri.parse(<span class="string">"http://abc"</span>), <span class="string">"video/mpeg"</span>);</div></pre></td></tr></table></figure>
<p> 或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">intent.setDataAndType(Uri.parse(<span class="string">"http://abc"</span>), <span class="string">"audio/mpeg"</span>);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>关于data还有一个特殊情况，也是它和action不同的地方，如下两种写法，它们的作用是一样的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"file"</span> <span class="attr">android:host</span>=<span class="string">"www.baidu.com"</span> /&gt;</span></div><div class="line">    <span class="comment">&lt;!--...--&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"file"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:host</span>=<span class="string">"www.baidu.com"</span> /&gt;</span></div><div class="line">    <span class="comment">&lt;!--...--&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当我们通过隐式方式启动一个Activity时，可以做一下判断，看是否有Activity能够匹配我们的隐式Intent，如果不在判断就有可能出现错误了。判断方法有两种：采用PackageManager的resolveActivity()方法或者Intent的resolveActivity()方法，如果它们找不到匹配的Activity就会返回null，我们通过判断返回值就可以了。另外PackageManager还提供了queryIntentActivities()方法，这个方法与resolveActivity()方法不同的是：它不是返回最佳匹配的Activity信息而是返回所有成功的Activity信息。以下是两个方法的声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;ResolveInfo&gt; <span class="title">queryIntentActivities</span><span class="params">(Intent intent,</span></span></div><div class="line"><span class="function"><span class="params">    @ResolveInfoFlags <span class="keyword">int</span> flags)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ResolveInfo <span class="title">resolveActivity</span><span class="params">(Intent intent, @ResolveInfoFlags <span class="keyword">int</span> flag)</span></span>;</div></pre></td></tr></table></figure>
<p>上述两个方法的第一个参数比较好理解，第二个参数需要注意，我们要使用MATCH_DEFAULT_ONLY这个标记位，这个标记位的含义是仅仅匹配那些在intent-filter中声明了<code>&lt;category android:android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</code>这个category的Activity。使用这个标记位的意义在于，只要上述两个方法不返回null，那么startActivity()就一定可以成功。如果不使用这个标记位，就可以把intent-filter中category不含DEFAULT的那些Activity匹配出来，从而导致startActivity()失败。</p>
<p>在action和category中，有一类action和category比较重要，它们是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android:intent.action.MAIN"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.inetnt.category.LAUNCHER"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>这两者共同作用是用来标明这是一个入口Activity，并且会出现在系统的应用列表中，少了任何一个都没有实际意义，也无法出现在系统的应用列表中。另外针对Service和BroadcastReceiver，PackageManager同样提供了类似的方法获取成功匹配的组件信息。</p>
<style type="text/css">
    p {
        text-indent: 2em; /*首行缩进*/
    }
</style></div><div class="tags"></div><div class="post-nav"><a href="/2017/11/25/Android-Senior-Dispatch-Event/" class="pre">Android高级进阶笔记-View的事件传递</a><a href="/2017/10/31/Java-Basic-ThreadPool/" class="next">Android线程和线程池</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = '长桥の情书';
var disqus_identifier = '2017/11/20/Android-Basic-Activity/';
var disqus_title = 'Android开发艺术探索笔记-Activity生命周期和启动模式';
var disqus_url = 'http://yoursite.com/2017/11/20/Android-Basic-Activity/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//长桥の情书.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/Day01-breaking/">第一天</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/14/Android-intent-bug/">Android 使用Intent传递参数时的一个bug</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/26/rx-Operate-Create-Start/">Start</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/Build-a-Responseive-UI-with-ConstraintLayout/">Build a Responseive UI with ConstraintLayout</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/17/html5-fkjava-char2/">疯狂HTML 5+CSS 3+JavaScript讲义笔记——2.HTML 5的常用元素与属性</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Error/">Error</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Empty/">Empty、Never、Throw</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Timer/">Timer</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Interval/">Interval</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Range/">Range</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//长桥の情书.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">长桥の情书.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>