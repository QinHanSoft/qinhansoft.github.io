<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android线程和线程池 | 长桥の情书</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android线程和线程池</h1><a id="logo" href="/.">长桥の情书</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android线程和线程池</h1><div class="post-meta">Oct 31, 2017</div><a data-disqus-identifier="2017/10/31/Java-Basic-ThreadPool/" href="/2017/10/31/Java-Basic-ThreadPool/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在Android中几乎完全采用了Java中的线程机制。线程是Android App中最小的调度单位，为了是App能够更加流畅的运行，很多时候我们不可能将所有的事情都放到主线程中执行，这样会造成很严重的卡顿（ANR），那么就有很多事情需要放到子线程去做。但是创建、销毁、调度线程都是需要开销的，所以我们也不能无限量的开启线程，那么对于线程和线程池的了解就变得尤为重要了。</p>
<h3 id="1-线程"><a href="#1-线程" class="headerlink" title="1. 线程"></a>1. 线程</h3><p>除了最常使用的Thread以外，在Android中可以扮演线程角色的还有很多，比如AsyncTask、HandlerThread和IntentService。虽然这些线程的表现形式跟基础的Thread有所不同，但本质上还是传统线程：例如AsyncTask的底层就使用了线程池；而HandlerThread和IntentService底层则直接使用了线程。</p>
<h4 id="1-1-Thread-Runnable-Callable"><a href="#1-1-Thread-Runnable-Callable" class="headerlink" title="1.1 Thread/Runnable/Callable"></a>1.1 Thread/Runnable/Callable</h4><p>一般实现线程的方法有两种：一种是类继承<em>Thread</em>，一种是实现接口<em>Runnable</em>。</p>
<ol>
<li><p>继承Thread</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.run();</div><div class="line">        Log.i(<span class="string">"MyThread"</span>, Thread.currentThread().getId());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> MyThread().start();</div></pre></td></tr></table></figure>
</li>
<li><p>实现Runnable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.i(<span class="string">"MyRunnable"</span>, Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">MyRunnable mRunnable = <span class="keyword">new</span> MyRunnable();</div><div class="line"><span class="keyword">new</span> Thread(mRunnable).start();</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<ol>
<li><p>Thread<br>调用Thread时，有两种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Thread mThread = <span class="keyword">new</span> Thread();</div><div class="line">mThread.run();</div><div class="line"></div><div class="line">Thread mThread = <span class="keyword">new</span> Thread();</div><div class="line">mThread.start();</div></pre></td></tr></table></figure>
<p>其中，run()方法只是调用了Thread实例的run()方法而已，它仍然运行在<em>主线程</em>上；而start()方法会先开辟一个线程，然后在这个新线程上调用run()方法，此时它运行在<em>子线程</em>上。</p>
</li>
<li><p>Runnable<br>Runnable只是一个接口，可能很多人以为Runnable实现了线程，这种理解是不对的。Runnable需要由Thread在线程中执行任务时调用其中的实现的run()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Callable<br>Runnable和Callable都代表那些要在不同线程中执行的任务。Runnable在JDK1.0开始就有了，而Callable是在JDK1.5时增加的，它们的区别是Callable的call()方法可以抛出异常、有返回值，而Runnable的run()方法就没有这个功能。Callable可以返回含有计算结果的Future对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>对比Runnable和Callable可知：</p>
<ul>
<li>Callable接口的方法是call()，而Runnable接口的方法是run()；</li>
<li>Callable任务执行时可以抛出异常，而Runnable任务执行时不能；</li>
<li>Callable任务执行完后有返回值，而Runnable任务执行之后没有返回值；</li>
<li>执行Callable任务可以得到一个Future对象，Future表示异步计算的结果，它提供了检查计算是否完成的方法，通过Future可以了解任务执行情况，取消任务，还可以获取执行结果。</li>
</ul>
<h4 id="1-2-FutureTask"><a href="#1-2-FutureTask" class="headerlink" title="1.2 FutureTask"></a>1.2 FutureTask</h4><p>但是，<em>Thread类只支持Runnable接口</em>，所以这里引入FutureTask的概念。FutureTask实现了Runnable和Future，所以兼有两者的优点，既可以在Thread中使用，又可以在ExecutorService中使用。</p>
<p>首先看一下Future的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</div><div class="line"></div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用FutureTask的好处是FutureTask是为了弥补Thread的不足而设计的，它可以让程序员准确的知道线程什么时候执行完成并获取到线程执行完成后返回的结果。</p>
<p>FutureTask是一种可以取消的异步任务，它的执行是通过Callable实现的，等价于一个可以携带结果的Runnable。</p>
<p>FutureTask有三种状态：等待、运行和完成，其中完成包括正常结束、取消和异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</div></pre></td></tr></table></figure>
<h4 id="1-3-AsyncTask"><a href="#1-3-AsyncTask" class="headerlink" title="1.3 AsyncTask"></a>1.3 AsyncTask</h4><p>AsyncTask是一个轻量级的异步任务类，它可以在线程池中执行后台任务，然后把执行的进度和结果传递回主线程。</p>
<h5 id="1-3-1-声明"><a href="#1-3-1-声明" class="headerlink" title="1.3.1 声明"></a>1.3.1 声明</h5><p>AsyncTask是一个抽象泛型类，声明是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt;</span></div></pre></td></tr></table></figure>
<p>三个泛型的意义：</p>
<ul>
<li>Params：表示异步任务的入参；</li>
<li>Progress：任务执行的进度；</li>
<li>Result：异步任务执行的结果。</li>
</ul>
<p>如果不需要传递具体的参数，那么这三个泛型可以定义为<code>Void</code>。</p>
<p>AsyncTask提供了4个核心方法，分别如下：</p>
<ul>
<li><em>onPreExecute()</em>：<strong>在主线程执行</strong>，在异步任务开始之前会调用此方法，一般用于做一些准备工作；</li>
<li><em>doInBackground(Params… params)</em>：<strong>在子线程执行</strong>，此方法用于执行异步任务，参数<em>params</em>表示异步任务的输入参数。在这个方法中可以通过<em>publishProgress()</em>方法来更新任务的进度，publishProgress()方法会调用<em>onProgressUpdate()</em>方法。这个方法需要返回计算结果给<em>onPostExecute()</em>；</li>
<li><em>onProgressUpdate(Progress… progress)</em>：<strong>在主线程执行</strong>，当后台任务的执行进度发生改变时此方法会被调用；</li>
<li><em>onPostExecute(Result result)</em>：<strong>在主线程执行</strong>，在异步任务执行之后此方法会被调用，其中result参数是后台任务的返回值，即doInBackground()的返回值。</li>
</ul>
<p>上面这几个方法，onPreExecute()方法最先执行，接着是doInBackground()，最后才是onPostExecute()。除了上述的四个方法外，AsyncTask还提供了onCancelled()方法，它同样<strong>在主线程执行</strong>，当异步任务被取消时，onCancelled()方法会被调用，这时候onPostExecute()方法不会被调用。</p>
<h5 id="1-3-2-限制条件"><a href="#1-3-2-限制条件" class="headerlink" title="1.3.2 限制条件"></a>1.3.2 限制条件</h5><p>AsyncTask在使用过程中有一些条件限制：</p>
<ol>
<li><p>AsyncTask类必须在主线程加载，就是说第一次访问AsyncTask必须是在主线程。当然在Android 4.1及以上版本中，这个操作已经被系统自动完成。在Android 5.0的源码中，有以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line"></div><div class="line">        AsyncTask.init();</div><div class="line"></div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>AsyncTask的对象必须在主线程中创建；</p>
</li>
<li>execute()方法必须在主线程调用；</li>
<li>不要在程序中直接调用onPreExecute()、onPostExecute()、doInBackground()和onProgressUpdate()方法必须在主线程调用；</li>
<li>一个AsyncTask对象只能执行一次，就是只能调用一次execute()方法，否则会报运行时异常；</li>
<li>在Android 1.6之前，AsyncTask是串行执行任务的，Android 1.6时AsyncTask开始采用线程池处理并行任务，但是从Android 3.0开始，为了避免AsyncTask所带来的并发错误，AsyncTask又采用一个线程来串行执行任务。尽管这样，在Android 3.0以及之后的版本中，我们仍然可以通过AsyncTask的executeOnExecutor()方法来并行地执行任务。</li>
</ol>
<h5 id="1-3-3-AsyncTask工作原理"><a href="#1-3-3-AsyncTask工作原理" class="headerlink" title="1.3.3 AsyncTask工作原理"></a>1.3.3 AsyncTask工作原理</h5><p>从execute()方法开始分析AsyncTask的工作原理。execute()会调用executeOnExecutor()方法。这里实际上调用进来后是一个串行的线程池，这个进程中所有的AsyncTask全都在这个线程池中排队执行，先调用onPreExecute()方法，然后线程池开始执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@MainThread</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@MainThread</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec, Params... params)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</div><div class="line">        <span class="keyword">switch</span> (mStatus) &#123;</div><div class="line">            <span class="keyword">case</span> RUNNING:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                    + <span class="string">" the task is already running."</span>);</div><div class="line">            <span class="keyword">case</span> FINISHED:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                    + <span class="string">" the task is already been executed "</span></div><div class="line">                    + <span class="string">"(a task can be executed only once)"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mStatus = Status.RUNNING;</div><div class="line"></div><div class="line">    onPreExecute();</div><div class="line"></div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先来看看SerialExecutor的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</div><div class="line">    Runnable mActive;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</div><div class="line">        mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    r.run();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    scheduleNext();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</div><div class="line">            scheduleNext();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据SerialExecutor的实现可以分析AsyncTask的排队执行的过程。首先系统会把AsyncTask#Params参数封装成FutureTask对象，FutureTask是一个并发类，在这里充当Runnable的作用，接着这个FutureTask会交给SerialExecutor#execute()方法去处理，这个方法首先会把FutureTask插入到任务队列mTasks中，如果这个时候没有正在活动的AsyncTask任务，就会调用SerialExecutor#scheduleNext()方法来执行下一个AsyncTask任务。同时，当一个AsyncTask任务执行完后，AsyncTask会继续执行下一个任务，直到所有任务都执行完毕为止，从这可以看出，默认情况下，AsyncTask是串行执行的。</p>
<p>AsyncTask中有两个线程池和一个Handler，其中线程池SerialExecutor负责任务排列，THREAD_POOL_EXECUTOR则用于真正执行任务，InternalHandler用于将执行环节从子线程切换到主线程，本质上仍然是线程的调用过程。</p>
<p>AsyncTask的构造方法中有如下代码，由于FutureTask的run()方法会调用mWorker的call()方法，隐藏mWorker的call()方法最终会在线程池中执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">            <span class="comment">//noinspection unchecked</span></div><div class="line">            Result result = doInBackground(mParams);</div><div class="line">            Binder.flushPendingCommands();</div><div class="line">            <span class="keyword">return</span> postResult(result);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在mWorker的call()方法中，首先将mTaskInvoked设置为true，表示当前任务已经被调用过了，然后执行AsyncTask的doInBackground()方法，接着将其返回值传递给postResult()方法，它的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码中，postResult()方法会通过sHandler发送一个MESSAGE_POST_RESULT的消息，这个sHandler的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(AsyncTask.class) &#123;</div><div class="line">        <span class="keyword">if</span> (sHandler == <span class="keyword">null</span>) &#123;</div><div class="line">            sHandler = <span class="keyword">new</span> InternalHandler();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sHandler;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(Looper.getMainLooper());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</div><div class="line">                <span class="comment">// There is only one result</span></div><div class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见这个sHandler是一个静态的Handler对象，为了能够将执行环境切换到主线程，这就要求sHandler必须在主线程中创建。由于静态成员会在加载类的时候初始化，这就变相要求AsyncTask必须在主线程中加载，否则同一进程中的AsyncTask都无法正常工作。sHandler收到消息后会调用AsyncTask#finish()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">        onCancelled(result);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        onPostExecute(result);</div><div class="line">    &#125;</div><div class="line">    mStatus = Status.FINISHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法逻辑比较简单，如果AsyncTask被取消了，就调用onCancelled()方法，否则就调用onPostExecute()方法，可以看到，doInBackground()方法的返回结果会传递给onPostExecute()方法。</p>
<p>整个AsyncTask执行流程如下：</p>
<p><img src="https://github.com/QinHanSoft/BlogImages/blob/master/FlowChart-AsyncTask.png?raw=true" alt=""></p>
<h5 id="1-3-4-基本使用"><a href="#1-3-4-基本使用" class="headerlink" title="1.3.4 基本使用"></a>1.3.4 基本使用</h5><p>从源码分析可知，AsyncTask异步任务在内部是串行执行的，为了提高异步任务的执行效率，在Android 3.0之后提供了executeOnExecutor()方法。</p>
<p>首先来一个一般的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">    ((<span class="keyword">new</span> MyAsyncTask(<span class="string">"MyAsyncTask01"</span>))).execute(<span class="string">""</span>);</div><div class="line">    ((<span class="keyword">new</span> MyAsyncTask(<span class="string">"MyAsyncTask02"</span>))).execute(<span class="string">""</span>);</div><div class="line">    ((<span class="keyword">new</span> MyAsyncTask(<span class="string">"MyAsyncTask03"</span>))).execute(<span class="string">""</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MyAsyncTask.class.getSimpleName();</div><div class="line">    <span class="keyword">private</span> String mName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAsyncTask</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mName = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</div><div class="line">        SystemClock.sleep(<span class="number">3000</span>);</div><div class="line">        <span class="keyword">return</span> mName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onPostExecute(s);</div><div class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>);</div><div class="line">        Log.i(TAG, s + <span class="string">" onPostExecute finish time: "</span> + format.format(<span class="keyword">new</span> Date()));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>触发后3个AsyncTask的创建和执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">I/MAsyncTask: MyAsyncTask01 onPostExecute finish time: 14:29:05</div><div class="line">I/MAsyncTask: MyAsyncTask02 onPostExecute finish time: 14:29:08</div><div class="line">I/MAsyncTask: MyAsyncTask03 onPostExecute finish time: 14:29:11</div></pre></td></tr></table></figure>
<p>如果使用executeOnExecutor()那么看下结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">new</span> MyAsyncTask(<span class="string">"MyAsyncTask01"</span>)).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, <span class="string">""</span>);</div><div class="line">(<span class="keyword">new</span> MyAsyncTask(<span class="string">"MyAsyncTask02"</span>)).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, <span class="string">""</span>);</div><div class="line">(<span class="keyword">new</span> MyAsyncTask(<span class="string">"MyAsyncTask03"</span>)).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, <span class="string">""</span>);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">I/MAsyncTask: MyAsyncTask02 onPostExecute finish time: 14:35:57</div><div class="line">I/MAsyncTask: MyAsyncTask03 onPostExecute finish time: 14:35:57</div><div class="line">I/MAsyncTask: MyAsyncTask01 onPostExecute finish time: 14:35:57</div></pre></td></tr></table></figure>
<h4 id="1-4-HandlerThread"><a href="#1-4-HandlerThread" class="headerlink" title="1.4 HandlerThread"></a>1.4 HandlerThread</h4><p>HandlerThread继承自Thread，是一种可以使用Handler的Thread，它的实现也很简单，就是在run()中通过Looper.prepare()来创建消息队列，这样在实际的使用中就允许在HandlerThread中创建Handler。HandlerThread的run()方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    mTid = Process.myTid();</div><div class="line">    Looper.prepare();</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line">    Process.setThreadPriority(mPriority);</div><div class="line">    onLooperPrepared();</div><div class="line">    Looper.loop();</div><div class="line">    mTid = -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从实现上来看，HandlerThread和普通的Thread有明显不同的地方，普通的Thread在run()方法中执行一个耗时任务，而HandlerThread在内部创建消息队列，外界需要通过Handler的消息方式来通知HandlerThread执行一个具体的任务。HandlerThread的一个具体使用场景是IntentService，将在下一节介绍。由于HandlerThread的run()方法是一个无限循环，所以在明确知道不在需要时，可以通过它的quit()或quitSafely()方法来终止线程的执行。</p>
<h4 id="1-5-IntentService"><a href="#1-5-IntentService" class="headerlink" title="1.5 IntentService"></a>1.5 IntentService</h4><p>IntentService是一个特殊的Service，是一个继承自Service的抽象类，可以用于执行后台耗时任务，任务执行完成后会自动停止。因为IntentService是一种Service，所以它的优先级要比普通的线程优先级更高，这样IntentService就比较适合执行一些优先级较高的后台任务。在实现上，IntentService封装了HandlerThread和Handler，可以从它的onCreate()方法中看出，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> It would be nice to have an option to hold a partial wakelock</span></div><div class="line">    <span class="comment">// during processing, and to have a static startService(Context, Intent)</span></div><div class="line">    <span class="comment">// method that would launch the service &amp; hand off a wakelock.</span></div><div class="line"></div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line">    HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</div><div class="line">    thread.start();</div><div class="line"></div><div class="line">    mServiceLooper = thread.getLooper();</div><div class="line">    mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在首次启动时，onCreate()方法会被调用，IntentService内部就会创建一个HandlerThread，并使用它的Looper来构造一个Handler对象mServiceHandler。这样，通过mServiceHandler发送的消息最终都会在HandlerThread中执行，这样看，IntentService也可以用于执行后台任务。每次启动IntentService，它的onStartCommand()方法就会被调用一次，IntentService在onStartCommand()中处理每个后台任务的Intent，来看一下onStartCommand()是如何处理外界Intent的：</p>
<p>首先onStartCommand()会调用onStart()方法。onStart()方法，它的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">    Message msg = mServiceHandler.obtainMessage();</div><div class="line">    msg.arg1 = startId;</div><div class="line">    msg.obj = intent;</div><div class="line">    mServiceHandler.sendMessage(msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里只是通过mServiceHandler发送了一个消息，所以这个消息会在HandlerThread中被处理。收到消息后，Intent对象会被传递给onHandlerIntent()方法中去处理。这个Intent对象的内容和外界startService(Intent)中Intent对象的内容是完全一致的，通过这个Intent对象就可以解析去外界启动IntentService所传递的参数，通过这些参数可以区分具体的后台任务，这样在onHandleIntent()方法中就可以对不同的后台任务做分别处理了。</p>
<p>onHandleIntent()方法执行结束后，IntentService会通过stopSelf(int startId)方法尝试停止服务，使用stopSelf(int)方法而不是stopSelf()方法的原因是stopSelf()方法会立刻停止服务，而这个时候可能还有其它消息没有处理，stopSelf(int)方法则会等待所有消息都处理完毕后才终止服务。stopSelf(int startId)在尝试停止服务之前会判断最近启动的服务次数是否和startId相等，如果相等就立刻停止服务，否则不停止服务，这个策略可以从AMS的stopServiceToken()方法的实现中找到依据。ServiceHandler的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(looper);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        onHandleIntent((Intent)msg.obj);</div><div class="line">        stopSelf(msg.arg1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>onHandleIntent()方法是一个抽象方法，需要我们在子类中实现，它的作用是从Intent参数中区分具体的任务并执行。如果只存在一个后台任务，那么onHandleIntent()方法执行完成后，stopSelf(int startId)会直接停止服务；如果目前存在多个后台任务，那么当onHandleIntent()执行完最后一个任务时，stopSelf(int startId)才会停止服务。</p>
<p>由于每执行一个后台任务就必须启动一次IntentService，而IntentService内部是通过消息的方式向HandlerThread请求执行任务，Handler中的Looper是顺序处理消息的，这样IntentService也是顺序执行的，当有多个任务同时存在时，这些后台任务会按照外界任务的发起顺序排队执行。</p>
<p>下面用代码来演示一遍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = LocalIntentService.class.getSimpleName();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LocalIntentService</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(TAG);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">        String task = intent.getStringExtra(<span class="string">"task"</span>);</div><div class="line">        Log.i(TAG, <span class="string">"receive task : "</span> + task);</div><div class="line">        SystemClock.sleep(<span class="number">2000</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.w(TAG, <span class="string">"onDestroy: "</span> + <span class="string">"关闭中"</span>);</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line"></div><div class="line">        Intent service = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, LocalIntentService.class);</div><div class="line">        service.putExtra(<span class="string">"task"</span>, <span class="string">"Hi, this is 1st data"</span>);</div><div class="line">        startService(service);</div><div class="line"></div><div class="line">        service.putExtra(<span class="string">"task"</span>, <span class="string">"Hi, this is 2nd data"</span>);</div><div class="line">        startService(service);</div><div class="line"></div><div class="line">        service.putExtra(<span class="string">"task"</span>, <span class="string">"Hi, this is 3rd data"</span>);</div><div class="line">        startService(service);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">11-21 14:33:33.831 16015-16273/com.qin.thread I/LocalIntentService: receive task : Hi, this is 1st data</div><div class="line">11-21 14:33:35.831 16015-16273/com.qin.thread I/LocalIntentService: receive task : Hi, this is 2nd data</div><div class="line">11-21 14:33:37.831 16015-16273/com.qin.thread I/LocalIntentService: receive task : Hi, this is 3rd data</div><div class="line">11-21 14:33:39.831 16015-16015/com.qin.thread W/LocalIntentService: onDestroy: 关闭中</div></pre></td></tr></table></figure>
<p>可以看出三个任务是排队执行的，它们的执行顺序就是它们发起请求的顺序。当任务3完成后，LocalIntentService才真正的停止。</p>
<h3 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2. 线程池"></a>2. 线程池</h3><p>说到线程池首先要说一下线程池的好处，线程池的优点可以概括为以下3点：</p>
<ol>
<li>重用线程池中的线程，避免因为线程的创建和销毁带了的性能开销；</li>
<li>能有效控制线程的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞现象；</li>
<li>能够对线程进行简单管理，并提供定时执行和指定间隔循环执行的能力。</li>
</ol>
<p>Android中的线程池的概念来源于Java中的Executor，Executor是一个接口，真正的线程池的实现是<strong>ThreadPoolExecutor</strong>。ThreadPoolExecutor提供了一系列参数来配置线程池，通过不同的参数可以创建不同的线程池。</p>
<h4 id="2-1-ThreadPoolExecutor"><a href="#2-1-ThreadPoolExecutor" class="headerlink" title="2.1 ThreadPoolExecutor"></a>2.1 ThreadPoolExecutor</h4><p>ThreadPoolExecutor是线程池的真正实现，它的构造方法提供了一系列参数来配置线程池，下面对线程池中的参数进行说明，这些参数将直接影响到线程池的功能特性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></div><div class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></div><div class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</div><div class="line">        Executors.defaultThreadFactory(), defaultHandler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h5><p>线程池的核心线程数，默认情况下，核心线程会在线程池中一直存活。如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程在等待新任务到来时会有超时策略，这个事件间隔有keepAliveTime指定，当等待时间超过keepAliveTime所指定的时长后，核心线程会被终止。</p>
<h5 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h5><p>线程池所能容纳的最大线程数，当活动线程数达到这个数值后，后续的任务就会被阻塞。</p>
<h5 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h5><p>非核心线程闲置超时时长，超过这个时长，非核心线程就会被回收。当ThreadPoolExecutor的allowCoreThreadTimeOut属性被设置为true时，keepAliveTime也会作用在核心线程上。</p>
<h5 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h5><p>指定keepAliveTime参数的时间单位，这个一个枚举类，常用的有TimeUnit.MILLISECONDS（毫秒）、TimeUnit.SECONDS（秒）和TimeUnit.MINUTES（分）等。</p>
<h5 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h5><p>线程池中的任务队列，通过线程池的execute()方法提交的Runnable对象会被存储在这个队列中。</p>
<p>WorkQueue是一个特殊的队列，当我们从BlockingQueue中取数据是，如果BlockingQueue是空的，取数据的操作就会进入到阻塞状态，当BlockingQueue中有了新的数据后，这个取数据操作又会被重新唤醒。同理，如果BlockingQueue中的数据已经满了，王BlockingQueue中存数据的操作会进入阻塞状态，知道BlockingQueue中又有了新的空间，存数据的操作又会被重新唤醒。</p>
<p>BlockingQueue有多种不同的实现类，下面举例说明：</p>
<ol>
<li>ArrayBlockingQueue：这是一个规定了大小的BlockingQueue，ArrayBlockingQueue的构造方法接收一个int类型的数据，这个数据表示BlockingQueue的大小，存储在ArrayBlockingQueue中的元素按照FIFO的顺序进行存取；</li>
<li><p>LinkedBlockingQueue：表示一个大小不确定的BlockingQueue，在LinkedBlockingQueue的构造方法中可以传一个int类型的数据，这样创建的LinkedBlockingQueue就是有大小的，也可以不传参数，不传时LinkedBlockingQueue的大小就是Integer.MAX_VALUE，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> LinkedBlockingQueue&#125; with a capacity of</span></div><div class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Integer.MAX_VALUE&#125;.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> LinkedBlockingQueue&#125; with ateh given (fixed) capacity.</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> capacity the capacity of the deque</span></div><div class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity&#125; is less than 1</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="keyword">this</span>.capacity = capacity;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>PriorityBlockingQueue：这个队列和LinkedBlockingQueue类型，不同的是PriorityBlockingQueue中的元素不是按照FIFO来排序的，而是按照元素的Comparator来决定存取顺序的（这个功能也反应了存入PriorityBlockingQueue中的数据必须实现Comparator接口）；</p>
</li>
<li>SynchronousQueue：表示一个同步Queue，属于线程安全的BlockingQueue的一种，在SynchronousQueue中，生成线程的插入操作必须要等待消费者线程的移除操作，Synchronous内部没有数据缓存空间，因此我们无法对SynchronousQueue进行读取或遍历操作，元素只有在你试图取走的时候才可能存在。</li>
</ol>
<p>排队原则如下：</p>
<ol>
<li>如果运行的线程少于corePoolSize，则Executor始终首选添加新的线程，而不进行排队；</li>
<li>如果允许的线程数量大于等于corePoolSize，则Executor始终首选将请求加入队列，而不添加新的线程；</li>
<li>如果无法将请求加入队列，则创建新的线程，除非创建次线程超出maximumPoolSize，这时任务将被拒绝。</li>
</ol>
<h5 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h5><p>线程工厂，为线程池提供创建新线程的功能。ThreadFactory是一个接口，它只有一个方法：<code>Thread newThread(Runnable r)</code>。</p>
<p>除了上面这些主要参数外，ThreadPoolExecutor还有一个不常用的参数<code>RejectedExecutionHandler handler</code>。当线程池无法执行新任务时，会调用handler的rejectedExecution()方法来通知调用者，默认情况下rejectedExecution()<br>方法会直接抛出一个RejectedExecutionException。ThreadPoolExecutor为RejectedExecutionHandler提供了几个可选值：CallerRunsPolicy、AboutPolicy、DiscardPolicy和DiscardOldestPolicy，其中AboutPolicy是默认参数。</p>
<ol>
<li>AboutPolicy：丢弃任务并抛出RejectedExecutionException通知调用者任务被抛弃；</li>
<li>CallerRunsPolicy：用调用者的线程执行新的任务，如果任务执行是有严格顺序的请不要使用这个policy；</li>
<li>DiscardPolicy：静默丢弃任务，不通知调用者，在处理网络请求时可以使用这种策略，静默丢弃没有经过处理的报文；</li>
<li>DiscardOldestPolicy：丢弃最老的任务，处理网络报文时可以使用这种策略，因为报文处理是有时效性的，超过时效的都必须丢弃。</li>
</ol>
<p>我们也可以定义一些自己的RejectedExecutionHandler，例如拒绝时，直接将线程加入缓存队列，并阻塞调用者，或根据任务的时间戳丢弃超过限制的任务。</p>
<h4 id="2-2-常用的4中线程池"><a href="#2-2-常用的4中线程池" class="headerlink" title="2.2 常用的4中线程池"></a>2.2 常用的4中线程池</h4><p>下面介绍一下不同特性的线程池，它们都直接或间接通过ThreadPoolExecutor来实现自己的功能。分别是：</p>
<h5 id="2-2-1-FixedThreadPool"><a href="#2-2-1-FixedThreadPool" class="headerlink" title="2.2.1 FixedThreadPool"></a>2.2.1 FixedThreadPool</h5><p><strong>通过Executors.newFixedThreadPool()方法来创建</strong>。它是一种线程数量固定的线程池，该线程池的线程全部是核心线程，没有超时机制且排队任务队列无限制，因为全部是核心线程，所以响应较快，且不用担心线程会被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                <span class="number">0L</span>, TimeUnit.MILLISENDS,</div><div class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数nThreads就是固定的核心线程数量。</p>
<h5 id="2-2-2-CacheThreadPool"><a href="#2-2-2-CacheThreadPool" class="headerlink" title="2.2.2 CacheThreadPool"></a>2.2.2 CacheThreadPool</h5><p><strong>通过Executors.newCachedThreadPool()方法创建</strong>。是一个数量无限大的线程池，它的所有线程都是非核心线程，当有新任务来时，如果没有空闲线程则直接创建新的线程而不去排队等待。超时时间都是60s，所以当线程空闲一段时间后就会被系统回收，所以理论上这个线程池不会有占用系统资源的无用线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                <span class="number">60L</span>, TimeUnit.SECONDS,</div><div class="line">                                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-2-3-ScheduledThreadPool"><a href="#2-2-3-ScheduledThreadPool" class="headerlink" title="2.2.3 ScheduledThreadPool"></a>2.2.3 ScheduledThreadPool</h5><p><strong>通过Executors.newScheduledThreadPool()方法来创建</strong>。ScheduledThreadPool像是上两种线程池的合体，它有数量固定的核心线程，且有数量无限多的非核心线程，但是它的非核心线程超时时间是0s，即非核心线程一旦空闲马上就会被回收。这类线程池适合执行定时任务和固定周期的重复任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span></span></div><div class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span></div><div class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_KEEPALIVE_MILLIS = <span class="number">10L</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</div><div class="line">            DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</div><div class="line">            <span class="keyword">new</span> DelayedWorkQueue());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数corePoolSize是核心线程数量。</p>
<ul>
<li>注：Android M开始，这个方法的实现修改成上述样子，即回收时间从0改为10ms。</li>
</ul>
<h5 id="2-2-4-SingleThreadExecutor"><a href="#2-2-4-SingleThreadExecutor" class="headerlink" title="2.2.4 SingleThreadExecutor"></a>2.2.4 SingleThreadExecutor</h5><p><strong>通过Executors.newSingleThreadPool()方法创建</strong>。它内部只有一个核心线程，确保所有任务进来都要排队按顺序执行。它的意义在于，统一所有的外界任务到同一线程中，让调用者可以忽略线程同步问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService new <span class="title">SingleThreadExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService(</div><div class="line">        <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * A wrapper class that exposes only the ScheduledExecutorService</span></div><div class="line"><span class="comment"> * methods of a ScheduledExecutorService implementation.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatedScheduledExecutorService</span></span></div><div class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">DelegatedExecutorService</span> </span></div><div class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</div><div class="line">    DelegatedScheduledExecutorService(ScheduledExecutorService executor) &#123;</div><div class="line">        <span class="keyword">super</span>(executor);</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-3-自定义线程池"><a href="#2-3-自定义线程池" class="headerlink" title="2.3 自定义线程池"></a>2.3 自定义线程池</h4><p>虽然线程池的使用跟具体场景有关，但是其实是有章可循的，我们先看一下几个经典的图片加载框架是怎样处理的：</p>
<h5 id="2-3-1-Android-Universal-Image-Loader-以下简称UIL"><a href="#2-3-1-Android-Universal-Image-Loader-以下简称UIL" class="headerlink" title="2.3.1 Android-Universal-Image-Loader(以下简称UIL)"></a>2.3.1 Android-Universal-Image-Loader(以下简称UIL)</h5><p>若开发者没有自己配置线程池，则会使用UIL的默认配置，在ImageLoaderConfiguration内部类Builder中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoaderConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="comment">/** &#123;<span class="doctag">@value</span>&#125; */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_THREAD_POOL_SIZE = <span class="number">3</span>;</div><div class="line">    <span class="comment">/** &#123;<span class="doctag">@value</span>&#125; */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_THREAD_PRIORITY = Thread.NORM_PRIORITY - <span class="number">2</span>;</div><div class="line">    <span class="comment">/** &#123;<span class="doctag">@value</span>&#125; */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_TASK_PROCESSING_TYPE = QueueProcessingType.FIFO;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> threadPoolSize = DEFAULT_THREAD_POOL_SIZE;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> threadPriority = DEFAULT_THREAD_PRIORITY;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> QueueProcessingType tasksProcessingType = DEFAULT_TASK_PROCESSING_TYPE;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initEmptyFieldsWithDefaultValues</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (taskExecutor == <span class="keyword">null</span>) &#123;</div><div class="line">                taskExecutor = DefaultConfigurationFactory</div><div class="line">                        .createExecutor(threadPoolSize, threadPriority, tasksProcessingType);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                customExecutor = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (taskExecutorForCachedImages == <span class="keyword">null</span>) &#123;</div><div class="line">                taskExecutorForCachedImages = DefaultConfigurationFactory</div><div class="line">                        .createExecutor(threadPoolSize, threadPriority, tasksProcessingType);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// ...</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中taskExecutor是加载任务线程池，taskExecutorForCachedImages是缓存处理线程池。</p>
<p>可见UIL的加载任务线程池和缓存处理线程池的默认大小都是3，同时默认线程优先级是Thread.NORM_PRIORITY - 2，这个优先级已经比较低了，主要是防止它抢占太多CPU时间片，从而影响主线程的执行，线程池的任务处理类型都是FIFO。</p>
<h5 id="2-3-2-Picasso"><a href="#2-3-2-Picasso" class="headerlink" title="2.3.2 Picasso"></a>2.3.2 Picasso</h5><p>Picasso也支持开发者自己配置线程池，如果没有配置则使用默认值，在Picasso#Builder#build()中，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Create the &#123;<span class="doctag">@link</span> Picasso&#125; instance. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> Picasso <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</div><div class="line">        service = <span class="keyword">new</span> PicassoExecutorService();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    Dispatcher dispatcher = <span class="keyword">new</span> Dispatcher(context, service, HANDLER, downloader, cache, stats);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,</div><div class="line">        defaultBitmapConfig, indicatorsEnabled, loggingEnabled);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用了自定义类PicassoExecutorService，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PicassoExecutorService</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_THREAD_COUNT = <span class="number">3</span>;</div><div class="line"></div><div class="line">    PicassoExecutorService() &#123;</div><div class="line">        <span class="keyword">super</span>(DEFAULT_THREAD_COUNT, DEFAULT_THREAD_COUNT, <span class="number">0</span>, TimeUnit.MILLISECONDS,</div><div class="line">            <span class="keyword">new</span> PriorityBlockingQueue&lt;Runnable&gt;(), <span class="keyword">new</span> Unit.PicassoThreadFactory());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</div><div class="line">        PicassoFutureTask ftask = <span class="keyword">new</span> PicassoFutureTask((BitmapHunter) task);</div><div class="line">        execute(ftask);</div><div class="line">        <span class="keyword">return</span> ftask;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见其默认线程大小为3，工作队列为有限阻塞队列，而Utils.PicassoThreadFactory()调用了PicassoThreadFactory，该类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PicassoThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"NullableProblems"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PicassoThread(r);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单，就是继承自ThreadFactory的工厂类，而PicassoThread如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PicassoThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PicassoThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(r);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        Process.setThreadPriority(THREAD_PRIORITY_BACKGROUND);</div><div class="line">        <span class="keyword">super</span>.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见其优先级是THREAD_PRIORITY_BACKGROUND。</p>
<p>但是，Picasso真正灵活的地方是可以根据网络情况调节线程池的大小，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustThreadCount</span><span class="params">(NetworkInfo info)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (info == <span class="keyword">null</span> || !info.isConnectedOrConnecting()) &#123;</div><div class="line">        setThreadCount(DEFAULT_THREAD_COUNT);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">switch</span> (info.getType()) &#123;</div><div class="line">        <span class="keyword">case</span> ConnectivityManager.TYPE_WIFI:</div><div class="line">        <span class="keyword">case</span> ConnectivityManager.TYPE_WIMAX:</div><div class="line">        <span class="keyword">case</span> ConnectivityManager.TYPE_ETHERNET:</div><div class="line">            setThreadCount(<span class="number">4</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ConnectivityManager.TYPE_MOBILE:</div><div class="line">            <span class="keyword">switch</span> (info.getSubtype()) &#123;</div><div class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_LTE: <span class="comment">// 4G</span></div><div class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_HSPAP:</div><div class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EHRPD:</div><div class="line">                    setThreadCount(<span class="number">3</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_UMTS: <span class="comment">// 3G</span></div><div class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_CDMA:</div><div class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EVDO_0:</div><div class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EVDO_A:</div><div class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EVDO_B:</div><div class="line">                    setThreadCount(<span class="number">2</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_GPRS:</div><div class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EDGE:</div><div class="line">                    setThreadCount(<span class="number">1</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    setThreadCount(DEFAULT_THREAD_COUNT);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            setThreadCount(DEFAULT_THREAD_COUNT);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即在WiFi环境下线程数为4，4G下线程数为3，3G下为2，2G下为1，默认情况是3。这样做的原因是在慢网络下下载速度慢，较少线程就足以处理。</p>
<h5 id="2-3-3-Glide"><a href="#2-3-3-Glide" class="headerlink" title="2.3.3 Glide"></a>2.3.3 Glide</h5><p>Glide的线程池也可以配置，下面我们看看它的默认配置，在GlideBuilder#createGlide()中，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function">Glide <span class="title">createGlide</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sourceExecutor == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.sourceExecutor = GlideExecutor.newSourceExecutor();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (diskCacheService == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Glide(</div><div class="line">        context, </div><div class="line">        engine, </div><div class="line">        memoryCache, </div><div class="line">        bitmapPool, </div><div class="line">        arrayPool, </div><div class="line">        requestManagerRetriever, </div><div class="line">        connectivityMonitorFactory, </div><div class="line">        logLevel, </div><div class="line">        defaultRequestOptions.lock(), </div><div class="line">        defaultTransitionOptions);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也是有两个线程池，其中sourceExecutor用于缓存未命中Glide的加载、解码和转换任务，diskCacheExecutor用于缓存命中时的加载、解码和转换任务。现在来看一下GlideExecutor.newSourceExecutor()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GlideExecutor <span class="title">newSourceExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> newSourceExecutor(calculateBestThreadCount(), DEFAULT_SOURCE_EXECUTOR_NAME,</div><div class="line">        UncaughtThrowableStrategy.DEFAULT);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GlideExecutor <span class="title">newSourceExecutor</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">        UncaughtThrowableStrategy uncaughtThrowableStrategy)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> newSourceExecutor(DEDAULT_DISK_CACHE_EXECUTOR_THREADS,</div><div class="line">            DEFAULT_DISK_CACHE_EXECUTOR_NAME, uncaughtThrowableStrategy);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GlideExecutor <span class="title">newSourceExecutor</span><span class="params">(<span class="keyword">int</span> threadCount, String name,</span></span></div><div class="line"><span class="function"><span class="params">    UncaughtThrowableStrategy uncaughtThrowableStrategy)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GlideExecutor(threadCount, name, uncaughtThrowableStrategy,</div><div class="line">        <span class="keyword">false</span> <span class="comment">/*preventNetworkOperations*/</span>, <span class="keyword">false</span> <span class="comment">/*executeSunchronously*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Visible for testing.</span></div><div class="line">GlideExecutor(<span class="keyword">int</span> poolsize, String name,</div><div class="line">    UncaughtThrowableStrategy uncaughtThrowableStrategy, <span class="keyword">boolean</span> preventNetworkOperations,</div><div class="line">    <span class="keyword">boolean</span> executeSynchronously) &#123;</div><div class="line">    <span class="keyword">this</span>(</div><div class="line">        poolsize <span class="comment">/* corePoolSize */</span>,</div><div class="line">        poolsize <span class="comment">/* maximumPoolSize */</span>,</div><div class="line">        <span class="number">0</span> <span class="comment">/* keepAliveTime */</span>,</div><div class="line">        name,</div><div class="line">        uncaughtThrowableStrategy,</div><div class="line">        preventNetworkOperations,</div><div class="line">        executeSynchronously);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在calculateBestThreadCount()方法中会根据CPU的数量和Java虚拟机中可用的处理器数量来选择合适的线程数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateBestThreadCount</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (bestThreadCount == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// We override the current ThreadPolicy to allow disk reads.</span></div><div class="line">        <span class="comment">// This shouldn't actually do disk-IO and accesses a device file.</span></div><div class="line">        <span class="comment">// See: https://github.com/bumptech/glide/issues/1170</span></div><div class="line">        ThreadPolicy originalPolicy = StrictMode.allowThreadDiskReads();</div><div class="line">        File[] cpus = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            File cpuInfo = <span class="keyword">new</span> File(CPU_LOCATION);</div><div class="line">            <span class="keyword">final</span> Pattern cupNamePattern = Pattern.compile(CPU_NAME_REGEX);</div><div class="line">            cpus = cpuInfo.listFiles(<span class="keyword">new</span> FilenameFilter() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file, String s)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> cupNamePattern.matcher(s).matches();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        &#125; finnally &#123;</div><div class="line">            StrictMode.setThreadPolicy(originalPolicy);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> cpuCount = cpus != <span class="keyword">null</span> ? cpus.length : <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> availableProcessors = Math.max(<span class="number">1</span>, Runtime.getRuntime().availableProcessors());</div><div class="line">        bestThreadCount = </div><div class="line">            Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, Math.max(availableProcessors, cpuCount));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> bestThreadCount;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再看Glide.newDiskCacheExecutor()，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GlideExecutor <span class="title">newDiskCacheExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,</div><div class="line">        DEFAULT_DISK_CACHE_EXECUTOR_NAME, UncaughtThrowableStrategy.DEFAULT);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GlideExecutor <span class="title">newDiskCacheExecutor</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">    UncaughtThrowableStrategy uncaughtThrowableStrategy)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,</div><div class="line">        DEFAULT_DISK_CACHE_EXECUTOR_NAME, uncaughtThrowableStrategy);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GlideExecutor <span class="title">newDiskCacheExecutor</span><span class="params">(<span class="keyword">int</span> threadCount, String name,</span></span></div><div class="line"><span class="function"><span class="params">    UncaughtThrowableStrategy uncaughtThrowableStrategy)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GlideExecutor(threadCount, name, uncaughtThrowableStrategy,</div><div class="line">        <span class="keyword">true</span> <span class="comment">/*preventNetworkOperations*/</span>, <span class="keyword">false</span> <span class="comment">/*executeSynchronously*/</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认值如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SOURCE_EXECUTOR_NAME = <span class="string">"source"</span>;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_DISK_CACHE_EXECUTOR_NAME = <span class="string">"disk-cache"</span>;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_DISK_CACHE_EXECUTOR_THREADS = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CPU_NAME_REGEX = <span class="string">"cpu[0-9]+"</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CPU_LOCATION = <span class="string">"/sys/devices/system/cpu/"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_AUTOMATIC_THREAD_COUNT = <span class="number">4</span>;</div></pre></td></tr></table></figure>
<p>可见，在Glide中，加载缓存未命中的线程池会根据CPU的数量和Java虚拟机中可用的处理器数量来选择线程数，最多不超过4个；加载缓存命中的线程池默认大小为1。</p>
<h4 id="2-4-一般使用"><a href="#2-4-一般使用" class="headerlink" title="2.4 一般使用"></a>2.4 一般使用</h4><ul>
<li>shutDown()：执行完已经提交的任务后关闭线程池，不影响已提交的任务；</li>
<li>shutDownNow()：尝试去终止已提交的任务并关闭线程池；</li>
<li>allowCoreThreadTimeOut(boolean)：设置允许核心线程闲置时超时回收；</li>
<li>execute()：无返回值的提交任务；</li>
<li>submit()：有返回值的提交任务，举例如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">    List&lt;Future&lt;String&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();</div><div class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>,</div><div class="line">            TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        Future&lt;String&gt; taskFuture = threadPoolExecutor.submit(<span class="keyword">new</span> MyTask(i));</div><div class="line">        <span class="comment">// 将每一个任务的执行结果保存起来</span></div><div class="line">        futures.add(taskFuture);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 遍历所有任务的执行结果</span></div><div class="line">        <span class="keyword">for</span> (Future&lt;String&gt; future : futures) &#123;</div><div class="line">            Log.d(TAG, <span class="string">"submit: "</span> + future.get());</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> taskId;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> taskId)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.taskId = taskId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        SystemClock.sleep(<span class="number">2000</span>);</div><div class="line">        <span class="comment">// 返回一个任务的执行结果</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"call()方法被调用----"</span> + Thread.currentThread().getName() + <span class="string">"----"</span> + taskId;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<style type="text/css">
    p {
        text-indent: 2em; /*首行缩进*/
    }
</style>

</div><div class="tags"></div><div class="post-nav"><a href="/2017/11/20/Android-Basic-Activity/" class="pre">Android开发艺术探索笔记-Activity生命周期和启动模式</a><a href="/2017/10/22/Java-Basic-DesignPatterns/" class="next">Java开发中的23种设计模式</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = '长桥の情书';
var disqus_identifier = '2017/10/31/Java-Basic-ThreadPool/';
var disqus_title = 'Android线程和线程池';
var disqus_url = 'http://yoursite.com/2017/10/31/Java-Basic-ThreadPool/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//长桥の情书.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/Day01-breaking/">第一天</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/14/Android-intent-bug/">Android 使用Intent传递参数时的一个bug</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/26/rx-Operate-Create-Start/">Start</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/Build-a-Responseive-UI-with-ConstraintLayout/">Build a Responseive UI with ConstraintLayout</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/17/html5-fkjava-char2/">疯狂HTML 5+CSS 3+JavaScript讲义笔记——2.HTML 5的常用元素与属性</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Error/">Error</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Empty/">Empty、Never、Throw</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Timer/">Timer</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Interval/">Interval</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Range/">Range</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//长桥の情书.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">长桥の情书.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>