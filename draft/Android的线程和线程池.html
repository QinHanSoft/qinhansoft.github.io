<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> | 长桥の情书</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">长桥の情书</h1><a id="logo" href="/.">长桥の情书</a><p class="description"></p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"></h1><div class="post-content"><p><a href="http://szysky.com/2016/08/22/%E3%80%8AAndroid-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B-11-Android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/" target="_blank" rel="external">Android的线程和线程池</a></p>
<p>除了最长使用的<em>Thread</em>之外，在Android之中可以扮演线程角色的还有很多，如<em>AsyncTask</em>和<em>IntentService</em>，同时<em>HandlerThread</em>也是一直特殊的线程。虽然这些线程的表现形式有别于基础线程，但是本质上还是传统的线程：例如<em>AsyncTask</em>它的底层使用了线程池。而对于<em>IntentService</em>和<em>HandlerThread</em>来说，它们的底层则直接使用了线程。</p>
<h3 id="1-根据不同的特性来实现不同的场景"><a href="#1-根据不同的特性来实现不同的场景" class="headerlink" title="1. 根据不同的特性来实现不同的场景"></a>1. 根据不同的特性来实现不同的场景</h3><ul>
<li><em>AsyncTask</em>：封装了线程池和Handler，它主要是为了方便开发者在子线程中更新UI；</li>
<li><em>HandlerThread</em>：是一种具有消息循环的线程，在它的内部可以使用Handler；</li>
<li><em>IntentService</em>：是一个服务，系统对齐进行了封装使其可以更方便的执行后台任务，IntentService内部采用了<em>HandlerThread</em>来执行任务，当任务执行完毕后<em>IntentService</em>会自动退出。从执行任务的角度来看，更像一个后台的线程，但是因为其本身是一种服务，所以导致不容易被系统杀死从而保证任务的执行，而如果是一个后台线程，由于这个时候进程中没有活动的四大组件，那么这个进程的优先级会很低，很容易被系统杀死，这就是<em>IntentService</em>的优点。</li>
</ul>
<h3 id="2-线程的简单概述"><a href="#2-线程的简单概述" class="headerlink" title="2. 线程的简单概述"></a>2. 线程的简单概述</h3><p>在操作系统中，线程是操作系统调度的最小单元，同时线程又是一种受限的系统资源，即线程不可能无限制的产生，并且线程的创建和销毁都会有相应的开销，当系统中存在大量的线程时，系统会通过时间片轮转的方式调度每个线程，因此线程不可能做到绝对的并行，除非线程数量小于等于CPU的核心数。但是这种情况太少了，所以线程池的概念就由此出现，通过线程池就可以避免因为频繁创建和销毁线程所带来的系统开销。</p>
<h3 id="3-主线程和子线程"><a href="#3-主线程和子线程" class="headerlink" title="3. 主线程和子线程"></a>3. 主线程和子线程</h3><p>主线程是指进程所拥有的线程，在Java中默认情况下一个进程只有一个线程，这个线程就是主线程。主线程主要处理界面交互相关的逻辑，因为用户随时会和界面发生交互，因此主线程在任何时候都必须有较高的响应速度，否则就会产生一种界面卡顿的感觉，为了保持较高的响应速度，就要去主线程中不能执行耗时的任务，这个时候子线程就派上用场。子线程也叫工作线程，除了主线程外的所有线程都叫子线程。</p>
<p>Android沿用了Java的线程模型，其中的线程也分为主线程和子线程，其中主线程也叫UI线程。主线程的作用是运行四大组件以及处理它们和用户的交互，而子线程的作用则是执行耗时任务，比如网络请求、I/O操作等。从Android 3.0开始系统要求网络访问必须在子线程中进行，否则网络访问就会失败并抛出<em>NetworkOnMainThreadException</em>这个异常，这样做是为了避免主线程由于耗时操作所阻塞从而出现ANR现象。</p>
<h3 id="4-Android中的线程形态"><a href="#4-Android中的线程形态" class="headerlink" title="4. Android中的线程形态"></a>4. Android中的线程形态</h3><h4 id="4-1-AsyncTask"><a href="#4-1-AsyncTask" class="headerlink" title="4.1 AsyncTask"></a>4.1 AsyncTask</h4><p><em>AsyncTask</em>是一种轻量级的异步任务类，它可以在线程池中执行后台任务，然后把执行的进度和最终的结果传递给主线程更新UI。从实现上来说，<em>AsyncTask</em>封装了Thread和Handler，通过<em>AsyncTask</em>可以更加方便地执行后台任务，对于特别耗时的任务来说，建议使用线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>AsyncTask</em>就是一个抽象的泛型类，这三个泛型的意义：</p>
<ul>
<li>Params：表示参数的类型</li>
<li>Progress：表示后台任务的执行进度的类型</li>
<li>Result：表示后台任务的返回结果的类型</li>
</ul>
<p>如果不需要传递具体的参数，那么这三个参数可以用Void来代替。</p>
<p><strong>AsyncTask提供了4个核心方法，含义如下：</strong></p>
<ol>
<li><em>onPreExecute()</em>：<strong>在主线程执行</strong>，在异步任务执行之前，此方法会被调用，一般可以用于做一些准备工作；</li>
<li><em>doInBackground()</em>：<strong>在子线程中执行</strong>，此方法用于执行异步任务，参数<em>params</em>表示异步任务的输入参数。在此方法中可以通过<em>publishProgress()</em>方法来更新任务的进度，<em>publishProgress()</em>等待会调用<em>onProgressUpdate()</em>方法。另外此方法需要返回计算结果给<em>onPostExecute()</em>；</li>
<li><em>onProgressUpdate()</em>：<strong>在主线程执行</strong>，当后台任务的执行进度发生改变时此方法会被调用；</li>
<li><em>onPostExecute()</em>：<strong>在主线程执行</strong>，在异步任务执行之后，此方法会被调用，其中<em>result</em>参数是后台任务的返回值，即<em>doInBackground()</em>的返回值。</li>
</ol>
<p>除了上述的四种方法，还有<em>onCancelled()</em>，它同样在主线程执行，当异步任务被取消时，<em>onCancelled()</em>方法会被调用，这个时候<em>onPostExecute()</em>则不会被调用。</p>
<p><strong>AsyncTask在使用过程中有一些条件限制</strong></p>
<ol>
<li><em>AsyncTask</em>的类必须在主线程被加载，这就意味着第一次访问<em>AsyncTask</em>必须发生在主线程，这个问题不是绝对，因为在Android 4.1及以上的版本已经被系统自动完成。在Android 5.0的源码中可以看到<em>ActivityThread#main()</em>会调用<em>AsyncTask#init()</em>方法；</li>
<li><em>AsyncTask</em>的类必须在主线程中创建；</li>
<li><em>execute()</em>方法必须在UI线程调用；</li>
<li>不要在程序中直接调用<em>onPreExecute()</em>，<em>onPostExecute()</em>，<em>doInBackground()</em>和<em>onProgressUpdate()</em>；</li>
<li>一个<em>AsyncTask</em>对象只能执行一次，即只能调用一次<em>execute()</em>方法，否则会报运行时异常；</li>
<li>在Android 1.6之前，<em>AsyncTask</em>是串行执行任务的，到Android 1.6的时候<em>AsyncTask</em>开始采用线程池处理并执行任务；但是Android 3.0开始，为了避免<em>AsyncTask</em>带来的并发错误，<em>AsyncTask</em>又采用了一个线程来串行的执行任务，尽管如此在3.0之后，仍然可以通过<em>AsyncTask#executeOnExecutor()</em>方法来并行执行任务。</li>
</ol>
<h4 id="4-2-AsyncTask的工作原理"><a href="#4-2-AsyncTask的工作原理" class="headerlink" title="4.2 AsyncTask的工作原理"></a>4.2 AsyncTask的工作原理</h4><p>这里以源码5.0来分析，不同的版本源码具体实现是不同的。</p>
<p>为了分析<em>AsyncTask</em>的工作原理，可以从它的<em>execute()</em>方法开始分析，<em>execute()</em>方法又会调用<em>executeOnExecutor()</em>方法。实际上这里调用进来后是一个串行的线程池，一个进程中所有的<em>AsyncTask</em>全都在这个串行的线程池中排队执行，然后会先调用<em>AysncTask#onPreExecute()</em>方法，然后线程池开始执行。看看<em>SerialExecutor</em>的源码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</div><div class="line">    Runnable mActive;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</div><div class="line">        mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    r.run();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    scheduleNext();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</div><div class="line">            scheduleNext();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<em>SerizalExecutor</em>的实现可以分析<em>AsyncTask</em>的排队执行的过程。首先系统会把<em>AsyncTask#Params</em>参数封装成<em>FutureTask</em>对象，<em>FutureTask</em>是一个并发类，在这里充当了<em>Runnable</em>的作用，接着这个<em>FutureTask</em>会交给<em>SerialExecutor#execute()</em>方法去处理，这个方法首先会把<em>FutureTask</em>对象插入到任务队列<em>mTasks</em>中，如果这个时候没有正在活动的<em>AsyncTask</em>任务，就会调用<em>SerialExecutor#scheduleNext()</em>方法来执行下一个<em>AsyncTask</em>任务。同时，当一个<em>AsyncTask</em>任务执行完后，<em>AsyncTask</em>会继续执行其它任务知道所有任务都执行完毕为止，从这一点可以看出，在默认情况下，<strong>AsyncTask是串行执行的</strong>。</p>
<p><em>AsyncTask</em>中有两个线程池（SerialExecutor和THREAD_POOL_EXECUTOR）和一个<em>Handler</em>（InternalHandler），其中线程池<em>SerialExecutor</em>用于任务的排列，而线程池<em>THREAD_POOL_EXECUTOR</em>用于真正的执行任务，而<em>InternalHandler</em>用于将执行环境从线程切换到主线程，其本质仍然是线程的调用过程。</p>
<p>在<em>AsyncTask</em>的构造方法中有如下这段代码，由于<em>FutureTask#run()</em>方法会调用<em>mWorker.call()</em>方法，因为mWorker的call()方法最终会在线程池中执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>((Looper) <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(@Nullable Hander handler)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(handler != <span class="keyword">null</span> ? handler.getLooper() : <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(@Nullable Looper callbackLooper)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line">            Result result = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">                <span class="comment">//noinspection unchecked</span></div><div class="line">                result = doInBackground(mParams);</div><div class="line">                Binder.flushPendingCommands();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</div><div class="line">                mCancelled.set(<span class="keyword">true</span>);</div><div class="line">                <span class="keyword">throw</span> tr;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                postResult(result);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<em>mWorker.call()</em>方法中，首先将<em>mTaskInvoked</em>设置成了true，表示当前任务已经被调用过了，然后执行<em>AsyncTask#doInBackground()</em>方法，接着将其返回值传递给<em>postResult()</em>，这个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，<em>postResult()</em>会通过<em>sHandler</em>发送一个<em>MESSAGE_POST_RESULT</em>消息，而<em>sHandler</em>的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> InternalHandler sHandler;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Handler mHandler;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mHandler;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(@Nullable Looper callbackLooper)</span> </span>&#123;</div><div class="line">    mHandler = callbackLooper == <span class="keyword">null</span> || callbackLooper == Looper.getMainLooper() ？ getMainHandler() : <span class="keyword">new</span> Handler(callbackLooper);</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Handler <span class="title">getMainHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (AsyncTask.class) &#123;</div><div class="line">        <span class="keyword">if</span> (sHandler == <span class="keyword">null</span>) &#123;</div><div class="line">            sHandler = <span class="keyword">new</span> InternalHandler(Looper.getMainLooper());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sHandler;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(looper);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarning</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        AysncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</div><div class="line">                <span class="comment">// There is only one result</span></div><div class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_PTOGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出<em>sHandler</em>是一个静态的Handler对象，为了能够将执行环境切换到主线程，这就要求<em>sHandler</em>这个对象必须在主线程中创建。由于静态成员会在加载类的时候初始化，因此就变相要求<em>AsyncTask</em>的类必须在主线程中加载，否则同一个进程中的<em>AsyncTask</em>都无法正常工作。<em>sHandler</em>收到消息后会调用<em>AsyncTask#finish()</em>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">        onCancelled(result);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        onPostExecute(result);</div><div class="line">    &#125;</div><div class="line">    mStatus = Status.FINISHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<em>finish()</em>方法很简单，如果<em>AsyncTask</em>被取消了，那么就调用<em>onCancelled()</em>方法，否则就调用<em>onPostExecute()</em>方法，可以看到<em>doInBackground()</em>的反馈结果会传递给<em>onPostExecute()</em>方法。</p>
<p>通过源码分析，可以确定从3.0开始，默认情况下<em>AsyncTask</em>就是串行的，通过一段代码测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">    ((<span class="keyword">new</span> MAsyncTask(<span class="string">"MyAsyncTask01"</span>))).execute(<span class="string">""</span>);</div><div class="line">    ((<span class="keyword">new</span> MAsyncTask(<span class="string">"MyAsyncTask02"</span>))).execute(<span class="string">""</span>);</div><div class="line">    ((<span class="keyword">new</span> MAsyncTask(<span class="string">"MyAsyncTask03"</span>))).execute(<span class="string">""</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MAsyncTask.class.getSimpleName();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MAsyncTask</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mName = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</div><div class="line">        SystemClock.sleep(<span class="number">3000</span>);</div><div class="line">        <span class="keyword">return</span> mName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onPostExecute(s);</div><div class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>);</div><div class="line">        Log.i(TAG, s + <span class="string">" onPostExecute finish time: "</span> + format.format(<span class="keyword">new</span> Date()));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>触发后3个<em>AsyncTask</em>的创建和执行，看下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">I/MAsyncTask: MyAsyncTask01 onPostExecute finish time: 14:29:05</div><div class="line">I/MAsyncTask: MyAsyncTask02 onPostExecute finish time: 14:29:08</div><div class="line">I/MAsyncTask: MyAsyncTask03 onPostExecute finish time: 14:29:11</div></pre></td></tr></table></figure>
<p>在5.1.1机器上测试所有的任务是串行执行的，总共耗时10秒，而在2.x的版本所有的结束时间却都是一样的。</p>
<p>如果使用<em>executeOnExecutor()</em>那么看一下结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">new</span> MAsyncTask(<span class="string">"MyAsyncTask01"</span>)).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, <span class="string">""</span>);</div><div class="line">(<span class="keyword">new</span> MAsyncTask(<span class="string">"MyAsyncTask01"</span>)).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, <span class="string">""</span>);</div><div class="line">(<span class="keyword">new</span> MAsyncTask(<span class="string">"MyAsyncTask01"</span>)).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, <span class="string">""</span>);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">I/MAsyncTask: MyAsyncTask02 onPostExecute finish time: 14:35:57</div><div class="line">I/MAsyncTask: MyAsyncTask03 onPostExecute finish time: 14:35:57</div><div class="line">I/MAsyncTask: MyAsyncTask01 onPostExecute finish time: 14:35:57</div></pre></td></tr></table></figure>
<p>可以根据需求选择使用哪种实现方式。</p>
<h4 id="4-3-HandlerThread"><a href="#4-3-HandlerThread" class="headerlink" title="4.3 HandlerThread"></a>4.3 HandlerThread</h4><p><em>HandlerThread</em>继承了<em>Thread</em>，它是一种可以使用<em>Handler</em>的Thread，它的实现也很简单，就是run()方法中通过<em>Looper.prepare()</em>来创建消息队列，并通过<em>Looper.loop()</em>来开启消息循环，这样在实际的使用中就允许在<em>HandlerThread</em>中创建<em>Handler</em>，看一下<em>run()</em>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    mTid = Process.myTid();</div><div class="line">    Looper.prepare();</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line">    Process.setThreadPriority(mPriority);</div><div class="line">    onLooperPrepared();</div><div class="line">    looper.loop();</div><div class="line">    mTid = -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从<em>HandlerThread</em>的实现来看，它和普通的Thread有显著的不同之处：普通的Thread主要用于在run()方法中执行一个耗时任务，而<em>HandlerThread</em>在内部创建了消息队列，外界需要通过Handler的消息方式来通知<em>HandlerThread</em>执行一个具体的任务。<em>HandlerThread</em>是一个很有用的类，在Android中一个具体使用场景就是<em>IntentService</em>。</p>
<p>由于<em>HandlerThread#run()</em>是一个无限循环方法，因此当明确不需要再使用<em>HandlerThread</em>时，最好通过<em>quit()</em>或者<em>quitSafely()</em>方法来终止线程的执行。</p>
<h4 id="4-4-IntentService"><a href="#4-4-IntentService" class="headerlink" title="4.4 IntentService"></a>4.4 IntentService</h4><p><em>IntentService</em>是一种特殊的<em>Service</em>，它继承了<em>Service</em>并且它是一个抽象类，因此需要创建子类才能使用。<em>IntentService</em>可以用于执行后台耗时任务，当任务执行后会自动停止，同时由于本质是服务的原因，它的优先级比单纯的线程要高的多，所以<em>IntentService</em>比较适合执行一些高优先级的后台任务。</p>
<p><em>IntentService</em>封装了<em>Handler</em>和<em>HandlerThread</em>，这是在<em>onCreate()</em>来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> It would be nice to have an option to hold a partial wakelock</span></div><div class="line">    <span class="comment">// during processing, and to have a static startService(Context, Intent)</span></div><div class="line">    <span class="comment">// method that would launch the service &amp; hand off a wakelock.</span></div><div class="line"></div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line">    HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</div><div class="line">    thread.start();</div><div class="line"></div><div class="line">    mServiceLooper = thread.getLooper();</div><div class="line">    mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当第一次启动的时候，<em>onCreate()</em>就会被调用，内部就会创建一个<em>HandlerThread</em>，然后使用它的<em>Looper</em>来构造一个<em>Handler</em>对象mServiceHandler。这样通过mServiceHandler发送的消息最终都会在<em>HandlerThread</em>中执行，从这个角度看<em>IntentService</em>也可以用于执行后台任务。</p>
<p>每次启动<em>IntentService</em>的时候，它的<em>onStartCommand()</em>方法就会被调用一次，<em>IntentService</em>在<em>onSatrtCommand()</em>处理每个后台任务的Intent。来看看源码是如何处理外界的Intent的：</p>
<p>首先<em>onStartCommand()</em>调用了<em>onStart()</em>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">    Message msg = mServiceHandler.obtainMessage();</div><div class="line">    msg.arg1 = startId;</div><div class="line">    msg.obj = intent;</div><div class="line">    mServiceHandler.sendMessage(msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法只是通过<em>mServiceHandler</em>发送了一个消息，所以这个消息绘制<em>HandlerThread</em>中被处理。消息收到后，会将Intent对象传递给<em>onHandleIntent()</em>方法去处理。注意这个<em>Intent</em>对象和外界<em>startService()</em>参数传递内容是一样的。通过Intent的参数就可以区分具体的后台任务，这样在<em>onHandleIntent()</em>方法中就可以对不同的后台任务做处理了。</p>
<p>当<em>onHandleIntent()</em>方法执行完毕后，<em>IntentService</em>会通过<em>stopSelf()</em>方法来停止服务。这里使用的方法是有参数的，不使用参数的<em>stopSelf()</em>是因为无参函数会立刻停止服务，可能会导致还没有执行完的任务失效。</p>
<p>有参的<em>stopSelf(int startId)</em>在尝试停止服务之前会判断最近启动的服务次数是否和startId这个参数值相等，如果相等就立刻停止服务，否则反之，这个策略可以从<em>AMS#stopServiceToken()</em>方法的实现中找到依据。</p>
<hr>
<p><em>IntentService#onHandleIntent()</em>方法是一个抽象方法，它需要我们在子类中实现，它的作用是从Intent参数中区分具体的任务并执行这些任务。如果目前只存在一个后台任务，那么<em>onHandleIntent()</em>方法执行完成后，<em>stopSelf(int startId)</em>会立即停止服务；如果目前存在多个后台任务，那么当<em>onHandleIntent()</em>方法执行完最后一个任务时，<em>stopSelf(int startId)</em>才会停止任务。另外由于每次执行一个后台任务都必须启动一次<em>IntentService</em>，而其内部则通过消息的方式向<em>HandlerThread</em>请求执行任务，<em>Handler中的Looper</em>是顺序处理消息的，这意味着<em>IntentService</em>也是顺序执行后台任务的，当有多个后台任务同时存在时，这些后台任务会按照外界发起的顺序排队执行。</p>
<p>用代码来演示一遍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = LocalIntentService.class.getSimpleName();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LocalIntentService</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(TAG);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">        String task = intent.getStringExtra(<span class="string">"task"</span>);</div><div class="line">        Log.i(TAG, <span class="string">"receiver task : "</span> + task);</div><div class="line">        SystemClock.sleep(<span class="number">2000</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.w(TAG, <span class="string">"onDestroy: "</span> + <span class="string">"关闭中"</span>);</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line"></div><div class="line">        Intent service = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, LocalIntentService.class);</div><div class="line">        service.putExtra(<span class="string">"task"</span>, <span class="string">"Hi, this is 1st data"</span>);</div><div class="line">        startService(service);</div><div class="line"></div><div class="line">        service.putExtra(<span class="string">"task"</span>, <span class="string">"Hi, this is 2nd data"</span>);</div><div class="line">        startService(service);</div><div class="line"></div><div class="line">        service.putExtra(<span class="string">"task"</span>, <span class="string">"Hi, this is 3rd data"</span>);</div><div class="line">        startService(service);</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">I/LocalIntentService: receiver task : Hi, this is 1st data</div><div class="line">I/LocalIntentService: receiver task : Hi, this is 2nd data</div><div class="line">I/LocalIntentService: receiver task : Hi, this is 3rd data</div><div class="line">W/LocalIntentService: onDestroy: 关闭中</div></pre></td></tr></table></figure>
<p>可以看出，三个后台任务是串行执行的，他们的执行顺序就是发钱请求的顺序。当任务3完成了之后<em>LocalIntentService</em>才真正的停止，因为这个时候执行了<em>onDestroy()</em>。</p>
<h3 id="5-Android中的线程池"><a href="#5-Android中的线程池" class="headerlink" title="5. Android中的线程池"></a>5. Android中的线程池</h3><p>概括一下线程池的优点：</p>
<ol>
<li>重用线程池中的线程，避免因为线程的创建和销毁带来的性能开销；</li>
<li>能有效控制线程的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞现象；</li>
<li>能够对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等能力。</li>
</ol>
<p>Android中的线程池的概念来源于Java中的<em>Executor</em>，<em>Executor</em>是一个接口，真正的线程池的实现为<em>ThreadPoolExecutor</em>。<em>ThreadPoolExecutor</em>提供了一系列参数来配置线程池，通过不同的参数可以创建不同的线程池。而从功能的特性来分的话可以分享四类，下面说明。</p>
<h4 id="5-1-ThreadPoolExecutor"><a href="#5-1-ThreadPoolExecutor" class="headerlink" title="5.1 ThreadPoolExecutor"></a>5.1 ThreadPoolExecutor</h4><p><em>ThreadPoolExecutor</em>是线程池的真正实现，它的构造方法提供了一系列参数来配置线程池，下面对构造方法中参数进行一下说明，这些参数将会直接影响到线程池的功能特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></div><div class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></div><div class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</div><div class="line">        Executors.defaultThreadFactory(), defaultHandler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><em>corePoolSize</em>：线程池的核心线程数，默认情况下，核心线程会在线程池中一直存活，即使都处于闲置状态。如果将<em>ThreadPoolExecutor#allowCoreThreadTimeOut</em>属性设置为<em>true</em>，那么闲置的核心线程在等待新任务到来时会有超时的策略，这个时间间隔由<em>keepAliveTime</em>属性来决定。当等待时间超过了<em>keepAliveTime</em>设置的值，那么核心线程将会终止；</li>
<li><em>maximumPoolSize</em>：线程池所能容纳的最大线程数，当活动线程数达到这个数值之后，后续的任务将会被阻塞；</li>
<li><em>keepAliveTime</em>：非核心线程闲置的超时时长，超过这个时长，非核心线程就会被回收；<em>allowCoreThreadTImeOut</em>这个属性为true时，这个属性同样会作用于核心线程；</li>
<li><em>unit</em>：用于指定<em>keepAliveTime</em>参数的时间单位，这是一个枚举，常用的有<em>TimeUnit.MILLISECONDS</em>（毫秒），<em>TimeUnit.SECONDS</em>（秒）和<em>TimeUnit.MUNUTES</em>（分）；</li>
<li><em>workQueue</em>：线程池中的任务队列，通过线程池的<em>execute()</em>方法提交的<em>Runnable</em>对象会存储在这个参数中；</li>
<li><em>threadFactory</em>：线程工程，为线程池提供创建新线程的功能，<em>ThreadFactory</em>是一个接口。</li>
</ul>
<p><strong>线程池执行任务时大致遵循如下规则：</strong></p>
<ol>
<li>如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务；</li>
<li>如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行；</li>
<li>如果在步骤2中无法将任务插入到任务队列中，这通常是因为任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务；</li>
<li>如果步骤3中的线程数量已经达到最大值，那么会拒绝执行此任务，<em>ThreadPoolExecutor</em>会调用<em>RejectedExecution</em>方法来通知调用者。</li>
</ol>
<hr>
<p><em>ThreadPoolExecutor</em>的参数配置在<em>AsyncTask</em>中有明显的体现，下面是其配置情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();</div><div class="line"></div><div class="line"><span class="comment">// We want at least 2 threads and at most 4 threads in the core pool,</span></div><div class="line"><span class="comment">// preferring to have 1 less than the CPU count to avoid saturating</span></div><div class="line"><span class="comment">// the CPU with background work</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = Math.max(<span class="number">2</span>, Math.min(CPU_COUNT - <span class="number">1</span>, <span class="number">4</span>));</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE_SECONDS = <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncTask #"</span> + mCount.getAndIncrement());</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =</div><div class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">128</span>);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * An &#123;<span class="doctag">@link</span> Executor&#125; that can be used to execute tasks in parallel.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR;</div><div class="line"></div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</div><div class="line">            sPoolWorkQueue, sThreadFactory);</div><div class="line">    threadPoolExecutor.allowCoreThreadTImeOut(<span class="keyword">true</span>);</div><div class="line">    THREAD_POOL_EXECUTOR = threadPoolExecutor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个配置后的规格是这样的：</p>
<ul>
<li>如果CPU数小于4个，核心线程数等于2，如果CPU数为4~5个，核心线程数等于CPU数-1，如果CPU数大于5个，核心线程数等于4；</li>
<li>线程池最大线程数为CPU数的2倍 + 1；</li>
<li>核心线程有超时机制，所有线程在闲置时的超时时间为30秒；</li>
<li>任务队列的容量为128。</li>
</ul>
<h3 id="6-线程池的分类"><a href="#6-线程池的分类" class="headerlink" title="6.线程池的分类"></a>6.线程池的分类</h3><h4 id="6-1-FixedThreadPool"><a href="#6-1-FixedThreadPool" class="headerlink" title="6.1 FixedThreadPool"></a>6.1 FixedThreadPool</h4><p><strong>通过<em>Executors.newFixedThreadPool()</em>方法来创建。</strong>它是一种线程数量固定的线程池，当线程处于空闲状态时，它们并不会被回收，除非线程池被关闭了。当所有线程都处于活动状态时，新任务都会处于等待状态，直到有线程空闲出来。由于<em>FixedThreadPool</em>只有核心线程并且这些核心线程不会被回收，这就意味着它能够更快速的响应外界的请求。</p>
<h4 id="6-2-CachedThreadPool"><a href="#6-2-CachedThreadPool" class="headerlink" title="6.2 CachedThreadPool"></a>6.2 CachedThreadPool</h4><p><strong>通过<em>Executors.newCacheedThreadPool()</em>方法来创建。</strong>它是一种线程数量不定的线程池，只有非核心线程，并且最大线程数为<em>Integer.MAX_VALUE</em>，这样就可以认为最大线程数为任意大了。当线程池中的线程都处于活动状态时，线程池会创建新的线程来处理新任务，否则就会利用空闲的线程来处理新任务。线程池中的空闲线程都有超时机制，超时时长为60秒，超过这个时间空闲线程就会被回收。</p>
<p>和<em>FixedThreadPool</em>不同的是，<em>CachedThreadPool</em>的任务队列其实相当于一个空集合，这将导致任何任务都会立即被执行，因为这种场景下<em>SynchronousQueue</em>是无法插入任务的。</p>
<p><em>SynchronousQueue</em>是一个非常特殊的队列，在很多情况下可以把它简单理解为一个无法存储数据的队列。<strong>在实际中很少使用，这里线程比较适合执行大量的耗时较少的任务。</strong></p>
<h4 id="6-3-ScheduledThreadPool"><a href="#6-3-ScheduledThreadPool" class="headerlink" title="6.3 ScheduledThreadPool"></a>6.3 ScheduledThreadPool</h4><p><strong>通过<em>Executors.newScheduledThreadPool()</em>方法来创建。</strong>它的核心线程数量是固定的，而非核心线程数量是没有限制的，并且当非核心线程空闲时会立即被回收掉。<strong>这类线程池用于执行定时任务和具有固定周期的重复任务。</strong></p>
<h4 id="6-4-SingleThreadExecutor"><a href="#6-4-SingleThreadExecutor" class="headerlink" title="6.4 SingleThreadExecutor"></a>6.4 SingleThreadExecutor</h4><p><strong>通过<em>Executors.newSingleThreadExecutor()</em>方法来创建。</strong>这类线程池内部只有一个核心线程，它确保所有的任务都在同一个线程中按顺序执行。<strong>这类线程池意义在于统一所有的外界任务到一个线程中，这是的在这些任务之间不需要处理线程同步问题。</strong></p>
</div></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = '长桥の情书';
var disqus_identifier = 'draft/Android的线程和线程池.html';
var disqus_title = '';
var disqus_url = 'http://yoursite.com/draft/Android的线程和线程池.html';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//长桥の情书.disqus.com/count.js" async></script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/Day01-breaking/">第一天</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/14/Android-intent-bug/">Android 使用Intent传递参数时的一个bug</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/26/rx-Operate-Create-Start/">Start</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/Build-a-Responseive-UI-with-ConstraintLayout/">Build a Responseive UI with ConstraintLayout</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/17/html5-fkjava-char2/">疯狂HTML 5+CSS 3+JavaScript讲义笔记——2.HTML 5的常用元素与属性</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Error/">Error</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Empty/">Empty、Never、Throw</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Timer/">Timer</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Interval/">Interval</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/rx-Operate-Create-Range/">Range</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//长桥の情书.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">长桥の情书.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>