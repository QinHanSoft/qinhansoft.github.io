<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> | 长桥の情书</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">长桥の情书</h1><a id="logo" href="/.">长桥の情书</a><p class="description"></p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"></h1><div class="post-content"><p>[toc]<br><a href="https://juejin.im/entry/593109e72f301e005830cd76" target="_blank" rel="external">Android线程和线程池一篇就够了</a></p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在Android中，几乎完全采用了Java中的线程机制。线程是最小的调度单位，在很多情况下为了使App更加流畅的运行，我们不可能将很多事情都放到主线程上执行，这样会造成严重的卡顿(ANR)，那么这些事情应该交给子线程去做，但是对于一个系统而言，创建、销毁、调度线程的过程是需要开销的，所以我们并不能无限量地开启线程，那么对线程的了解就变得尤为重要了。</p>
<h3 id="1-Thread-Runnable-Callable"><a href="#1-Thread-Runnable-Callable" class="headerlink" title="1. Thread/Runnable/Callable"></a>1. Thread/Runnable/Callable</h3><p>一般实现线程的方法有两种，一种是类继承Thread，一种是实现接口Runnable。这两种方式的优缺点如何呢？我们知道Java是单继承但可以实现多个接口，所以看起来Runnable更加好一些。</p>
<h4 id="1-1-继承Thread"><a href="#1-1-继承Thread" class="headerlink" title="1.1 继承Thread"></a>1.1 继承Thread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.run();</div><div class="line">        Log.i(Thread.currentThread().getId());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> MyThread().start();</div></pre></td></tr></table></figure>
<h4 id="1-2-实现Runnable接口"><a href="#1-2-实现Runnable接口" class="headerlink" title="1.2 实现Runnable接口"></a>1.2 实现Runnable接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="title">implememts</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.i(<span class="string">"MyThread"</span>, Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</div><div class="line"><span class="keyword">new</span> Thread(myThread).start();</div></pre></td></tr></table></figure>
<p>当我们调用Thread时，会有两种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Thread mThread = <span class="keyword">new</span> Thread();</div><div class="line">mThread.run();</div><div class="line">mThread.start();</div></pre></td></tr></table></figure>
<p>我们应该知道，run()方法只是调用了Thread实例的run()方法而已，它仍然运行在主线程上，而start()方法会开辟一个新的线程，在新的线程上调用run()方法，此时它运行在新的线程上。</p>
<p>Runnable只是一个接口，所以单看这个接口它和线程毫无瓜葛，可能一部分人会以为Runnable实现了线程，这种理解是不对的。Thread调用了Runnable接口中的方法用来在线程中执行任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Runnable和Callable都代表那些要在不同线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的call()方法可以有返回值和抛出异常，而Runnable的run()方法就没有这些功能。Callable可以返回装载有计算结果的Future对象。</p>
<p>我们通过对比两个接口得到这样的结论：</p>
<ul>
<li>Callable接口下的方法是call()，Runnable接口的方法是run()；</li>
<li>Callable的任务执行后可以由返回值，而Runnable的任务是不能有返回值的；</li>
<li>call()方法可以抛出异常，run()方法是不可以的；</li>
<li>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>
</ul>
<p>然而，Thread类只支持Runnable接口，由此引入FutureTask的概念。</p>
<h3 id="2-FutureTask"><a href="#2-FutureTask" class="headerlink" title="2. FutureTask"></a>2. FutureTask</h3><p>FutureTask实现了Runnable和Future，所以兼顾两者优点，既可以在Thread中使用，又可以在ExecutorService中使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</div><div class="line"></div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用FutureTask的好处是FutureTask是为了弥补Thread的不足而设计的，它可以让程序员准确地知道线程什么时候执行完成并获得线程执行完成后返回的结果。FutureTask是一种可以取消的异步的计算任务，它的计算是通过Callable实现的，它等价于可以携带结果的Runnable，并且有三个状态：等待、运行和完成。完成包括所有计算以任意的方式结束，包括正常结束、取消和异常。</p>
<p>除了以上这些，在Android中充当线程的角色还有AsyncTask、HandlerThread、IntentService。它们本质上都是有Handler+Thread来构成的，不过不同的设计让它们可以在不同的场合发挥更好的作用。我们来简单地说一下它们各自的特点：</p>
<ul>
<li>AsyncTask，它封装了线程池和Handler，主要为我们在子线程中更新UI提供便利；</li>
<li>HandlerThread，它是个具有消息队列的线程，可以方便我们在子线程中处理不同的事务；</li>
<li>IntentService，我们可以将它看做为HandlerThread的升级版，它是服务，优先级更高。</li>
</ul>
<p>下面我们通过源码，用法等来认清这些线程。</p>
<h3 id="3-AsyncTask"><a href="#3-AsyncTask" class="headerlink" title="3. AsyncTask"></a>3. AsyncTask</h3><p>AsyncTask是一个轻量级的异步任务类，它可以在线程池中执行后台任务，然后把执行的进度和结果传递给主线程并且在主线程中更新UI。</p>
<h4 id="3-1-用法"><a href="#3-1-用法" class="headerlink" title="3.1 用法"></a>3.1 用法</h4><p>AsyncTask是一个抽象泛型类，声明是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AysncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt;</span></div></pre></td></tr></table></figure>
<p>并且提供了4个核心方法。</p>
<ul>
<li>参数1，Params，异步任务的入参；</li>
<li>参数2，Progress，执行任务的进度；</li>
<li>参数3，Result，后台任务执行的结果；</li>
<li>方法1，onPreExecute()，在主线程中执行，任务开启前的准备工作；</li>
<li>方法2，doInBackground(Params…params)，开启子线程执行后台任务；</li>
<li>方法3，onProgressUpdate(Progress values)，在主线程中执行，更新UI进度；</li>
<li>方法4，onPostExecute(Result result)，在主线程中执行，异步任务执行完成后执行，它的参数是doInBackground()的返回值。</li>
</ul>
<p>从上面我们可以清晰地了解到AsyncTask的具体用法，但是为什么它是这样表现的呢？或者说，为什么它是这样而非其它样子，那么我们就来看看源码吧。</p>
<h4 id="3-2-源码分析"><a href="#3-2-源码分析" class="headerlink" title="3.2 源码分析"></a>3.2 源码分析</h4><p>我们知道开启AsyncTask异步任务是通过new MyAsyncTask().execute()开启的，我们就以此入口开始分析。</p>
<h5 id="3-2-1-execute-方法"><a href="#3-2-1-execute-方法" class="headerlink" title="3.2.1 execute()方法"></a>3.2.1 execute()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@MainThread</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params...params)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析：从源码中，可以看到execute()方法调用了executeOnExecutor()方法。</p>
<h5 id="3-2-2-executeOnExecutor-方法"><a href="#3-2-2-executeOnExecutor-方法" class="headerlink" title="3.2.2 executeOnExecutor()方法"></a>3.2.2 executeOnExecutor()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@MainThread</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AysncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></div><div class="line"><span class="function"><span class="params">        Params...params)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</div><div class="line">        <span class="keyword">switch</span> (mStatus) &#123;</div><div class="line">            <span class="keyword">case</span> RUNNING:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannnot execute task:"</span></div><div class="line">                        + <span class="string">" the task is already running."</span>);</div><div class="line">            <span class="keyword">case</span> FINISHED:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannnot execute task:"</span></div><div class="line">                        + <span class="string">" the task has already been executed "</span></div><div class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mStatus = Status.RUNNING;</div><div class="line"></div><div class="line">    onPreExecute();</div><div class="line"></div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析：mStatus代表了当前异步任务的运行状态，我们可以看出AsyncTask是一次性的，即不能重复调用execute()来开启异步任务。当该任务第一次启动时，状态设置为RUNNING，并且调用onPreExecute()即上午中提到了的核心方法1。毫无疑问，此方法是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@MainThread</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>是需要我们来实现的。</p>
<p>然后我们将参数1（Params）给了MWorker。</p>
<p>从3.2.1可以看到3.2.2中反复的参数exec就是sDefaultExecutor。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="title">implememts</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</div><div class="line">    Runnable mActive;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</div><div class="line">        mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    r.run();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    scheduleNext();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</div><div class="line">            scheduleNext();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，它用来实现AsyncTask的排队执行，即AsyncTask是串行而非并发执行的。源码的大致执行过程我们会在下面给出流程图。</p>
<h5 id="3-2-3-mWorker的call-方法"><a href="#3-2-3-mWorker的call-方法" class="headerlink" title="3.2.3 mWorker的call()方法"></a>3.2.3 mWorker的call()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> WorkRunnable&lt;Params, Result&gt; mWorker;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(@Nullable Looper callbackLooper)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line">            Result result = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">                <span class="comment">//noinspection unchecked</span></div><div class="line">                result = doInBackground(mParams);</div><div class="line">                Binder.flushPendingCommands();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</div><div class="line">                mCancelled.set(<span class="keyword">true</span>);</div><div class="line">                <span class="keyword">throw</span> tr;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                postResult(result);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，此时开始执行AsyncTask的核心方法2，当然也是需要我们自己实现的。</p>
<h5 id="3-2-4-sHandler"><a href="#3-2-4-sHandler" class="headerlink" title="3.2.4 sHandler"></a>3.2.4 sHandler</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarning</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在3.2.3中可以看到最后执行到了postResult()方法，这个方法就是利用一个静态sHandler变量将消息发送出去并且交由主线程处理，这样一来就实现了子线程和主线程的切换问题。不仅仅是这里由sHandler处理，当在子线程中执行doInBackground()时，如果我们需要更新进度即调用核心方法3也需要利用sHandler发送消息给主线程处理。</p>
<h5 id="3-2-5-finish"><a href="#3-2-5-finish" class="headerlink" title="3.2.5 finish"></a>3.2.5 finish</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result return)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">        onCancelled(result);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        onPostExecute(result);</div><div class="line">    &#125;</div><div class="line">    mStatus = Status.FINISHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从3.2.4中看到，发送sHandler的MESSAGE_POST_RESULT消息，执行了finish()方法。该方法很简单，如果政策结束调用了核心方法4结束整个异步任务。如果在异步任务执行的过程中被取消了，那么调用onCancelled()方法。<br><img src="https://github.com/QinHanSoft/BlogImages/blob/master/AsyncTask流程.png?raw=true" alt=""></p>
<h4 id="3-3-基本使用"><a href="#3-3-基本使用" class="headerlink" title="3.3 基本使用"></a>3.3 基本使用</h4><p>从源码分析中，可以看到AsyncTask异步任务在内部是串行执行的，为了提高异步任务的注销效率，在Android 3.0之后提供了executeOnExecutor()方法。</p>
<p>来一个一般写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String mName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAsyncTask</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mName = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@TargetApi</span>(Build.VERSION_CODES.N)</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doInBackground</span><span class="params">(Object[] params)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">3000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line">        Log.i(mName, dateFormat.format(<span class="keyword">new</span> Date(System.currentTimeMillis())));</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以通过这样的调用来验证其是串行还是并发的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">new</span> MAsyncTask(<span class="string">"MyAsyncTask01"</span>)).execute();</div><div class="line">(<span class="keyword">new</span> MAsyncTask(<span class="string">"MyAsyncTask02"</span>)).execute();</div><div class="line">(<span class="keyword">new</span> MAsyncTask(<span class="string">"MyAsyncTask03"</span>)).execute();</div></pre></td></tr></table></figure>
<p>可以看到这三个异步任务的执行时间是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">I/MyAsyncTask01: 2017-10-31 10:08:39</div><div class="line">I/MyAsyncTask02: 2017-10-31 10:08:42</div><div class="line">I/MyAsyncTask03: 2017-10-31 10:08:45</div></pre></td></tr></table></figure>
<p>可知它的执行是串行的，如果需要并发执行，调用executeOnExecutor()即可:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">new</span> MAsyncTask(<span class="string">"MyAsyncTask01"</span>)).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, <span class="string">""</span>);</div><div class="line">(<span class="keyword">new</span> MAsyncTask(<span class="string">"MyAsyncTask02"</span>)).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, <span class="string">""</span>);</div><div class="line">(<span class="keyword">new</span> MAsyncTask(<span class="string">"MyAsyncTask03"</span>)).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, <span class="string">""</span>);</div></pre></td></tr></table></figure>
<p>日志是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">I/MyAsyncTask03: 2017-10-31 10:11:43</div><div class="line">I/MyAsyncTask02: 2017-10-31 10:11:43</div><div class="line">I/MyAsyncTask01: 2017-10-31 10:11:43</div></pre></td></tr></table></figure>
<h3 id="4-HandlerThread"><a href="#4-HandlerThread" class="headerlink" title="4. HandlerThread"></a>4. HandlerThread</h3><p>HandlerThread继承了Thread，我们都知道如果需要在线程中创建一个可接收消息的Handler，可以参考另一篇文章<a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fweixin_36244867%2Farticle%2Fdetails%2F54881870" target="_blank" rel="external">Android消息机制-Handler</a>。所以HandlerThread实际上是一个允许Handler的特殊线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    mTid = Process.MyTid;</div><div class="line">    Looper.prepare();</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line">    Process.setThreadPriority(mPriority);</div><div class="line">    onLooperPrepared();</div><div class="line">    Looper.loop();</div><div class="line">    mTid = -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>普通线程在run()方法中执行耗时操作，而HandlerThread在run()方法中创建了一个消息队列，不停的轮询消息，我们可以通过Handler发送消息来告诉线程该执行什么操作。</p>
<p>它在Android中是一个很有用的类，常见的场景是在IntentService中。当我们不再需要HandlerThread时，通过调用quit()/quitSaftly()方法来结束线程的轮询并结束该线程。</p>
<h3 id="5-IntentService"><a href="#5-IntentService" class="headerlink" title="5. IntentService"></a>5. IntentService</h3><h4 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h4><p>IntentService是一个继承自Service的抽象类，所以必须实现它的子类燃区使用。</p>
<p>在说到HandlerThread时提到，HandlerThread的使用场景是在IntentService上，我们可以这样来理解IntentService：它是一个实现了HandlerThread的Service。</p>
<p>那么，为什么要这样设计呢？这样设计的好处是Service的优先级比较高，我们可以利用这个特性来保证后台服务的优先正常执行，甚至我们还可以为Service开辟一个新的进程。</p>
<h4 id="5-2-源码分析"><a href="#5-2-源码分析" class="headerlink" title="5.2 源码分析"></a>5.2 源码分析</h4><p>先来看看onCreate()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line">    HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</div><div class="line">    thread.start();</div><div class="line"></div><div class="line">    mServiceLooper = thread.getLooper();</div><div class="line">    mServiceHandler= <span class="keyword">new</span> ServiceHandler(mServiceLooper);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到创建Service时，实现了一个HandlerThread的实例开启了一个线程，并在线程内部进行消息轮询，又创建了一个Handler来收发Looper的消息。</p>
<p>我们每启动一次服务时，并不会开启新的服务，只是会调用onStartCommand()方法，这个方法又调用了onStart()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">    Message msg = mServiceHandler.obtainMessage();</div><div class="line">    msg.arg1 = startId;</div><div class="line">    msg.obj = intent;</div><div class="line">    mServiceHandler.sendMessage(msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在onStart()方法中看到，这里接收Context传递的参数，通过Handler发送出去，然后在HandlerThread的线程上接收消息并处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(looper);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        onHandleIntent((Intent)msg.obj);</div><div class="line">        stopSelf(msg.arg1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到onHandleIntent方法是我们需要接收消息处理的。</p>
<p>流程如下：<br><img src="https://github.com/QinHanSoft/BlogImages/blob/master/IntentService执行流程.png?raw=true" alt=""></p>
<h3 id="6-初始线程池"><a href="#6-初始线程池" class="headerlink" title="6. 初始线程池"></a>6. 初始线程池</h3><p>在上面的篇幅中，讲到了线程的概念和一些扩展线程。那么我们考虑一个问题，如果需要同时做很多事情，是不是给每一个事件都开启一个线程呢？那么如果我的事件无限多呢？频繁地创建/销毁线程，CPU该吃不消了吧。所以，线程池的概念就来了。我们举一个例子来阐述一下线程池大致工作原理。</p>
<p>比如，有个老板戚总开了个饭店，每到中午就有很多人点外卖，一开始戚总招了10个人送外卖，然而由于午饭高峰期可能同时需要派送50份外卖，那如何保证高效地运行呢？</p>
<p>再招40个员工送？那这饭店不是要亏死，并且大部分时候也只需要同时派送几份外卖而已，招这么多人干瞪眼啊。但是我还得保证高峰期送餐效率，咋办呢？</p>
<p>经过一番思想斗争，戚总想通了，我也不可能做到完美，尽量高效就行了，那正常时间一般只需要同时送四五家外卖，那就招5个员工作为正式员工（核心线程），再招若干兼职（非核心线程）在用餐高峰期时缓解一下送餐压力即可。</p>
<p>那么，人员分配方案出来了，当正式员工（核心线程）空闲时有单进来理所应当让他们派送，如果正式员工忙不过来了，就让兼职人员（非核心线程）送。</p>
<p>好吧，这就是线程池的概念原理吧~</p>
<p>总结一下优点：</p>
<ul>
<li>重用线程池中的线程，避免频繁的创建和销毁线程带来的性能消耗；</li>
<li>有效控制线程的最大并发量，防止线程过大导致抢占资源造成系统阻塞；</li>
<li>可以对线程进行一定的管理。</li>
</ul>
<h3 id="7-ThreadPoolExecutor"><a href="#7-ThreadPoolExecutor" class="headerlink" title="7. ThreadPoolExecutor"></a>7. ThreadPoolExecutor</h3><p>ExecutorService是最初的线程池接口，ThreadPoolExecutor类都是对线程池的具体实现，它通过构造方法来配置线程池的参数，我们来分析一下它常用的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></div><div class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></div><div class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</div><div class="line">        Executors.defaultThreadFactory(), defaultHandler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数解释：</p>
<ul>
<li>corePoolSize，线程池中核心线程的数量，默认情况下，即使核心线程没有任务在执行也会存在，我们固定一定数量的信息线程且它们一直存活，这样就避免了一般情况下CPU创建和销毁线程带来的开销。如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么现在的核心线程就会有超时策略，这个事件有keepAliveTime来设定，即keepAliveTime时间内如果核心线程没有回应则该线程就会被终止。allowCoreThreadTimeOut默认为false，核心线程没有超时时间。</li>
<li>maximumPoolSize，线程池中的最大线程数，当任务数量超过最大线程数时其它任务可能就会被阻塞。最大线程数=核心线程数+非核心线程数。非核心线程只有当核心线程不够用且线程池有空余时才会被创建，执行完成后非核心线程会被销毁。</li>
<li>keepAliveTime，非核心线程的超时时长，当执行时间超过这个时间时，非核心线程就会被回收。当allowCoreThreadTimeOut设置为true时，此属性也作用在核心线程上。</li>
<li>unit，枚举时间单位，TimeUnit。</li>
<li>workQueue，线程池中的任务队列，我们提交给线程池的润那边了会被存储在这个对象中。</li>
</ul>
<p>线程池的分配遵循这样的规则：</p>
<ul>
<li>当线程池中的核心线程数量未达到最大值时，启动一个核心线程去执行任务；</li>
<li>如果线程池中核心线程达到最大线程数，那么任务会被插入到任务队列中排队等待执行；</li>
<li>如果在上一步骤中任务队列已满但是线程池中线程数量未达到限定线程总数，那么启动一个非核心线程来处理任务；</li>
<li>如果上一步骤中线程数量达到了限定线程总量，那么线程池则拒绝执行该任务，且ThreadPoolExecutor会调用RejectedtionHandler的rejectedExecution()方法来通知调用者。</li>
</ul>
<h3 id="8-线程池的分类"><a href="#8-线程池的分类" class="headerlink" title="8. 线程池的分类"></a>8. 线程池的分类</h3><p>我们来介绍一下不同特性的线程池，它们都直接或间接通过ThreadPoolExecutor来实现自己的功能。分别是：</p>
<ul>
<li>FixedThreadPool</li>
<li>CachedThreadPool</li>
<li>ScheduledThreadPool</li>
<li>SingleThreadExecutor</li>
</ul>
<h4 id="8-1-FixedThreadPool"><a href="#8-1-FixedThreadPool" class="headerlink" title="8.1 FixedThreadPool"></a>8.1 FixedThreadPool</h4><p>通过Executors的newFixedThreadPool()方法创建，它是个线程数量固定的线程池，该线程池的线程全部为核心线程，它们没有超时机制且排队任务队列无限制，因为全都是核心线程，所以响应较快，且不用担心线程会被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数nThreads，就是我们固定的核心线程数量。</p>
<h4 id="8-2-CachedThreadPool"><a href="#8-2-CachedThreadPool" class="headerlink" title="8.2 CachedThreadPool"></a>8.2 CachedThreadPool</h4><p>通过Executors的newCachedThreadPool()方法来创建，它是一个数量无限多的线程池，它的所有线程都是非核心线程，当有新人物来时如果没有空闲的线程则直接创建新的线程不去排队而直接执行，并且超时时间都是60s，所以当线程空闲一定时间时就会被系统回收，所以理论上这个线程池不会有占用系统资源的无用线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</div><div class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="8-3-ScheduledThreadPool"><a href="#8-3-ScheduledThreadPool" class="headerlink" title="8.3 ScheduledThreadPool"></a>8.3 ScheduledThreadPool</h4><p>通过Executors的newScheduledThreadPool()方法来创建，ScheduledThreadPool线程池向上上两种的合体，它有数量固定的核心线程，且有数量无限多的非核心线程，但是它的非核心线程超时时间是0s，即非核心线程一旦空闲马上就会被回收。这类线程池适合于执行定时任务和固定周期的重复任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span></span></div><div class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span></div><div class="line"><span class="class">        <span class="title">implememts</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</div><div class="line">            DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</div><div class="line">            <span class="keyword">new</span> DelayedWorkQueue());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数corePoolSize是核心线程数量。</p>
<ul>
<li>注：Android M开始，这个方法的参数修改为上述样子，回收时间从0改为10ms。</li>
</ul>
<h4 id="8-4-SingleThreadExecutor"><a href="#8-4-SingleThreadExecutor" class="headerlink" title="8.4 SingleThreadExecutor"></a>8.4 SingleThreadExecutor</h4><p>通过Executors的newSingleThreadExecutor()方法来创建，它内部只有一个核心线程，它确保所有任务进来都要排队按顺序执行。它的意义在于，统一所有的外界任务到统一线程中，让调用者可以忽略线程同步问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</div><div class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</div><div class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="9-线程池一般用法"><a href="#9-线程池一般用法" class="headerlink" title="9. 线程池一般用法"></a>9. 线程池一般用法</h3><ul>
<li>shutDown()，关闭线程池，需要执行完已提交的任务；</li>
<li>shutDownNow()，关闭线程池，并尝试结束已提交的任务；</li>
<li>allowCoreThreadTimeOut(boolean)，允许核心线程闲置时超时回收；</li>
<li>execute()，提交任务，无返回值；</li>
<li>submit()，提交任务，有返回值。</li>
</ul>
<h3 id="10-自定义线程池"><a href="#10-自定义线程池" class="headerlink" title="10. 自定义线程池"></a>10. 自定义线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExecutorService mExecutor = Executors.newFixedThreadPool(<span class="number">5</span>);</div></pre></td></tr></table></figure>
<h3 id="11-execute"><a href="#11-execute" class="headerlink" title="11. execute()"></a>11. execute()</h3><p>接收一个Runnable对象作为参数，异步执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Runnable myRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.i(<span class="string">"myRunnable"</span>, <span class="string">"run"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">mExecutor.execute(myRunnable);</div></pre></td></tr></table></figure>
</div></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = '长桥の情书';
var disqus_identifier = 'draft/Android线程和线程池一篇就够了.html';
var disqus_title = '';
var disqus_url = 'http://yoursite.com/draft/Android线程和线程池一篇就够了.html';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//长桥の情书.disqus.com/count.js" async></script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/31/Java-Basic-ThreadPool/">Android线程和线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/22/Java-Basic-DesignPatterns/">Java开发中的23种设计模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/21/Java-Basic-DesignPhilosophy/">面向对象的六大设计原则</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/21/Java-Basic-OOP/">Java面向对象三大特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/20/Android/">Android技能树</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/28/Android-Code-Standards/">Android编码规范</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/15/Android-Table-Drive/">表驱动法在Android下的一个实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/10/Picasso-Basic-Scale/">Picasso图片缩放</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/22/Picasso-Basic-PlaceHolder/">Picasso占位符</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/09/Picasso-Basic/">Picasso基本使用</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//长桥の情书.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">长桥の情书.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>